/* Automatically generated from ../src/admin/admin_protocol.x by gendispatch.pl.
 * Do not edit this file.  Any changes you make will be lost.
 */
static int adminDispatchDaemonClose(
    virNetServerPtr server,
    virNetServerClientPtr client,
    virNetMessagePtr msg,
    virNetMessageErrorPtr rerr);
static int adminDispatchDaemonCloseHelper(
    virNetServerPtr server,
    virNetServerClientPtr client,
    virNetMessagePtr msg,
    virNetMessageErrorPtr rerr,
    void *args ATTRIBUTE_UNUSED,
    void *ret ATTRIBUTE_UNUSED)
{
  int rv;
  virThreadJobSet("adminDispatchDaemonClose");
  VIR_DEBUG("server=%p client=%p msg=%p rerr=%p args=%p ret=%p",
            server, client, msg, rerr, args, ret);
  rv = adminDispatchDaemonClose(server, client, msg, rerr);
  virThreadJobClear(rv);
  return rv;
}
/* adminDispatchDaemonClose body has to be implemented manually */



static int adminDispatchDaemonGetVersion(
    virNetServerPtr server,
    virNetServerClientPtr client,
    virNetMessagePtr msg,
    virNetMessageErrorPtr rerr,
    admin_daemon_get_version_ret *ret);
static int adminDispatchDaemonGetVersionHelper(
    virNetServerPtr server,
    virNetServerClientPtr client,
    virNetMessagePtr msg,
    virNetMessageErrorPtr rerr,
    void *args ATTRIBUTE_UNUSED,
    void *ret)
{
  int rv;
  virThreadJobSet("adminDispatchDaemonGetVersion");
  VIR_DEBUG("server=%p client=%p msg=%p rerr=%p args=%p ret=%p",
            server, client, msg, rerr, args, ret);
  rv = adminDispatchDaemonGetVersion(server, client, msg, rerr, ret);
  virThreadJobClear(rv);
  return rv;
}
static int adminDispatchDaemonGetVersion(
    virNetServerPtr server ATTRIBUTE_UNUSED,
    virNetServerClientPtr client,
    virNetMessagePtr msg ATTRIBUTE_UNUSED,
    virNetMessageErrorPtr rerr,
    admin_daemon_get_version_ret *ret)
{
    int rv = -1;
    unsigned long long libVer;
    struct daemonAdmClientPrivate *priv =
        virNetServerClientGetPrivateData(client);

    if (!priv->dmn) {
        virReportError(VIR_ERR_INTERNAL_ERROR, "%s", _("connection not open"));
        goto cleanup;
    }

    if (adminDaemonGetVersion(priv->dmn, &libVer) < 0)
        goto cleanup;

    ret->libVer = libVer;
    rv = 0;

cleanup:
    if (rv < 0)
        virNetMessageSaveError(rerr);
    return rv;
}



static int adminDispatchDaemonOpen(
    virNetServerPtr server,
    virNetServerClientPtr client,
    virNetMessagePtr msg,
    virNetMessageErrorPtr rerr,
    admin_daemon_open_args *args);
static int adminDispatchDaemonOpenHelper(
    virNetServerPtr server,
    virNetServerClientPtr client,
    virNetMessagePtr msg,
    virNetMessageErrorPtr rerr,
    void *args,
    void *ret ATTRIBUTE_UNUSED)
{
  int rv;
  virThreadJobSet("adminDispatchDaemonOpen");
  VIR_DEBUG("server=%p client=%p msg=%p rerr=%p args=%p ret=%p",
            server, client, msg, rerr, args, ret);
  rv = adminDispatchDaemonOpen(server, client, msg, rerr, args);
  virThreadJobClear(rv);
  return rv;
}
/* adminDispatchDaemonOpen body has to be implemented manually */



virNetServerProgramProc adminProcs[] = {
{ /* Unused 0 */
   NULL,
   0,
   (xdrproc_t)xdr_void,
   0,
   (xdrproc_t)xdr_void,
   true,
   0
},
{ /* Method DaemonOpen => 1 */
   adminDispatchDaemonOpenHelper,
   sizeof(admin_daemon_open_args),
   (xdrproc_t)xdr_admin_daemon_open_args,
   0,
   (xdrproc_t)xdr_void,
   true,
   0
},
{ /* Method DaemonClose => 2 */
   adminDispatchDaemonCloseHelper,
   0,
   (xdrproc_t)xdr_void,
   0,
   (xdrproc_t)xdr_void,
   true,
   0
},
{ /* Method DaemonGetVersion => 3 */
   adminDispatchDaemonGetVersionHelper,
   0,
   (xdrproc_t)xdr_void,
   sizeof(admin_daemon_get_version_ret),
   (xdrproc_t)xdr_admin_daemon_get_version_ret,
   true,
   0
},
};
size_t adminNProcs = ARRAY_CARDINALITY(adminProcs);
