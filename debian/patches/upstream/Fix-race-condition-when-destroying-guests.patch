From: =?UTF-8?q?Ferenc=20W=C3=A1gner?= <wferi@niif.hu>
Date: Wed, 21 Aug 2013 18:58:06 +0200
Subject: Fix race condition when destroying guests

Backport of 81621f3e6e45e8681cc18ae49404736a0e772a11 and
f1b4021b38f9485c50d386af6f682ecfc8025af5 to fix a race (resulting in a
segfault) when destroying domains.
---
 src/qemu/qemu_driver.c | 19 +++++++++++++------
 1 file changed, 13 insertions(+), 6 deletions(-)

diff --git a/src/qemu/qemu_driver.c b/src/qemu/qemu_driver.c
index 0053ed1..c0b4707 100644
--- a/src/qemu/qemu_driver.c
+++ b/src/qemu/qemu_driver.c
@@ -1827,6 +1827,12 @@ qemuDomainDestroyFlags(virDomainPtr dom,
 
     qemuDomainSetFakeReboot(driver, vm, false);
 
+
+    /* We need to prevent monitor EOF callback from doing our work (and sending
+     * misleading events) while the vm is unlocked inside BeginJob/ProcessKill API
+     */
+    priv->beingDestroyed = true;
+
     /* Although qemuProcessStop does this already, there may
      * be an outstanding job active. We want to make sure we
      * can kill the process even if a job is active. Killing
@@ -1834,19 +1840,20 @@ qemuDomainDestroyFlags(virDomainPtr dom,
      */
     if (flags & VIR_DOMAIN_DESTROY_GRACEFUL) {
         if (qemuProcessKill(driver, vm, 0) < 0) {
+            priv->beingDestroyed = false;
             qemuReportError(VIR_ERR_OPERATION_FAILED, "%s",
                             _("failed to kill qemu process with SIGTERM"));
             goto cleanup;
         }
     } else {
-        ignore_value(qemuProcessKill(driver, vm, VIR_QEMU_PROCESS_KILL_FORCE));
+        if (qemuProcessKill(driver, vm, VIR_QEMU_PROCESS_KILL_FORCE) < 0) {
+            priv->beingDestroyed = false;
+            qemuReportError(VIR_ERR_OPERATION_FAILED, "%s",
+                            _("failed to kill qemu process with SIGTERM"));
+            goto cleanup;
+        }
     }
 
-    /* We need to prevent monitor EOF callback from doing our work (and sending
-     * misleading events) while the vm is unlocked inside BeginJob API
-     */
-    priv->beingDestroyed = true;
-
     if (qemuDomainObjBeginJobWithDriver(driver, vm, QEMU_JOB_DESTROY) < 0)
         goto cleanup;
 
