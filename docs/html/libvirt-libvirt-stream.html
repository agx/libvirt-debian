<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <!--
        This file is autogenerated from html/libvirt-libvirt-stream.html.in
        Do not edit this file. Changes will be lost.
      -->
  <!--
        This page was generated at Thu Feb 28 00:29:58 UTC 2019.
      -->
  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <link rel="stylesheet" type="text/css" href="../main.css"/>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/>
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/>
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/>
    <link rel="manifest" href="/manifest.json"/>
    <meta name="theme-color" content="#ffffff"/>
    <title>libvirt: Module libvirt-stream from libvirt</title>
    <meta name="description" content="libvirt, virtualization, virtualization API"/>
    <script type="text/javascript">
      <!--
          
      function init() {
          window.addEventListener('scroll', function(e){
              var distanceY = window.pageYOffset || document.documentElement.scrollTop,
              shrinkOn = 94
              home = document.getElementById("home");
              links = document.getElementById("jumplinks");
              search = document.getElementById("search");
              body = document.getElementById("body");
              if (distanceY > shrinkOn) {
                  if (home.className != "navhide") {
                      body.className = "navhide"
                      home.className = "navhide"
                      links.className = "navhide"
                      search.className = "navhide"
                  }
              } else {
                  if (home.className == "navhide") {
                      body.className = ""
                      home.className = ""
                      links.className = ""
                      search.className = ""
                  }
              }
          });
      }
      window.onload = init();
           
          -->
    </script>
  </head>
  <body>
    <div id="body">
      <div id="content">
        <h1>Module libvirt-stream from libvirt</h1>
        <p>Provides APIs for the management of streams Copyright (C) 2006-2014 Red Hat, Inc. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this library. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
        <h2>Table of Contents</h2>
        <h3>
          <a href="#types">Types</a>
        </h3>
        <pre class="api"><span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virStreamEventType">virStreamEventType</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virStreamFlags">virStreamFlags</a>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <a href="#virStreamRecvFlagsValues">virStreamRecvFlagsValues</a>
</pre>
        <h3>
          <a href="#functions">Functions</a>
        </h3>
        <pre class="api"><span class="type">int</span>	<a href="#virStreamAbort">virStreamAbort</a>			(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream)
<span class="type">int</span>	<a href="#virStreamEventAddCallback">virStreamEventAddCallback</a>	(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream, <br/>					 <span class="type">int</span> events, <br/>					 <span class="type"><a href="libvirt-libvirt-stream.html#virStreamEventCallback">virStreamEventCallback</a></span> cb, <br/>					 <span class="type">void *</span> opaque, <br/>					 <span class="type"><a href="libvirt-libvirt-common.html#virFreeCallback">virFreeCallback</a></span> ff)
<span class="keyword">typedef</span> <a href="#virStreamEventCallback">virStreamEventCallback</a>
<span class="type">void</span>	<a href="#virStreamEventCallback">virStreamEventCallback</a>		(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream, <br/>					 <span class="type">int</span> events, <br/>					 <span class="type">void *</span> opaque)

<span class="type">int</span>	<a href="#virStreamEventRemoveCallback">virStreamEventRemoveCallback</a>	(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream)
<span class="type">int</span>	<a href="#virStreamEventUpdateCallback">virStreamEventUpdateCallback</a>	(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream, <br/>					 <span class="type">int</span> events)
<span class="type">int</span>	<a href="#virStreamFinish">virStreamFinish</a>			(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream)
<span class="type">int</span>	<a href="#virStreamFree">virStreamFree</a>			(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream)
<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span>	<a href="#virStreamNew">virStreamNew</a>		(<span class="type"><a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a></span> conn, <br/>					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virStreamRecv">virStreamRecv</a>			(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream, <br/>					 <span class="type">char *</span> data, <br/>					 <span class="type">size_t</span> nbytes)
<span class="type">int</span>	<a href="#virStreamRecvAll">virStreamRecvAll</a>		(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream, <br/>					 <span class="type"><a href="libvirt-libvirt-stream.html#virStreamSinkFunc">virStreamSinkFunc</a></span> handler, <br/>					 <span class="type">void *</span> opaque)
<span class="type">int</span>	<a href="#virStreamRecvFlags">virStreamRecvFlags</a>		(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream, <br/>					 <span class="type">char *</span> data, <br/>					 <span class="type">size_t</span> nbytes, <br/>					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virStreamRecvHole">virStreamRecvHole</a>		(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream, <br/>					 <span class="type">long long *</span> length, <br/>					 <span class="type">unsigned int</span> flags)
<span class="type">int</span>	<a href="#virStreamRef">virStreamRef</a>			(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream)
<span class="type">int</span>	<a href="#virStreamSend">virStreamSend</a>			(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream, <br/>					 <span class="type">const char *</span> data, <br/>					 <span class="type">size_t</span> nbytes)
<span class="type">int</span>	<a href="#virStreamSendAll">virStreamSendAll</a>		(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream, <br/>					 <span class="type"><a href="libvirt-libvirt-stream.html#virStreamSourceFunc">virStreamSourceFunc</a></span> handler, <br/>					 <span class="type">void *</span> opaque)
<span class="type">int</span>	<a href="#virStreamSendHole">virStreamSendHole</a>		(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream, <br/>					 <span class="type">long long</span> length, <br/>					 <span class="type">unsigned int</span> flags)
<span class="keyword">typedef</span> <a href="#virStreamSinkFunc">virStreamSinkFunc</a>
<span class="type">int</span>	<a href="#virStreamSinkFunc">virStreamSinkFunc</a>		(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> st, <br/>					 <span class="type">const char *</span> data, <br/>					 <span class="type">size_t</span> nbytes, <br/>					 <span class="type">void *</span> opaque)

<span class="keyword">typedef</span> <a href="#virStreamSinkHoleFunc">virStreamSinkHoleFunc</a>
<span class="type">int</span>	<a href="#virStreamSinkHoleFunc">virStreamSinkHoleFunc</a>		(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> st, <br/>					 <span class="type">long long</span> length, <br/>					 <span class="type">void *</span> opaque)

<span class="keyword">typedef</span> <a href="#virStreamSourceFunc">virStreamSourceFunc</a>
<span class="type">int</span>	<a href="#virStreamSourceFunc">virStreamSourceFunc</a>		(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> st, <br/>					 <span class="type">char *</span> data, <br/>					 <span class="type">size_t</span> nbytes, <br/>					 <span class="type">void *</span> opaque)

<span class="keyword">typedef</span> <a href="#virStreamSourceHoleFunc">virStreamSourceHoleFunc</a>
<span class="type">int</span>	<a href="#virStreamSourceHoleFunc">virStreamSourceHoleFunc</a>		(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> st, <br/>					 <span class="type">int *</span> inData, <br/>					 <span class="type">long long *</span> length, <br/>					 <span class="type">void *</span> opaque)

<span class="keyword">typedef</span> <a href="#virStreamSourceSkipFunc">virStreamSourceSkipFunc</a>
<span class="type">int</span>	<a href="#virStreamSourceSkipFunc">virStreamSourceSkipFunc</a>		(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> st, <br/>					 <span class="type">long long</span> length, <br/>					 <span class="type">void *</span> opaque)

<span class="type">int</span>	<a href="#virStreamSparseRecvAll">virStreamSparseRecvAll</a>		(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream, <br/>					 <span class="type"><a href="libvirt-libvirt-stream.html#virStreamSinkFunc">virStreamSinkFunc</a></span> handler, <br/>					 <span class="type"><a href="libvirt-libvirt-stream.html#virStreamSinkHoleFunc">virStreamSinkHoleFunc</a></span> holeHandler, <br/>					 <span class="type">void *</span> opaque)
<span class="type">int</span>	<a href="#virStreamSparseSendAll">virStreamSparseSendAll</a>		(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream, <br/>					 <span class="type"><a href="libvirt-libvirt-stream.html#virStreamSourceFunc">virStreamSourceFunc</a></span> handler, <br/>					 <span class="type"><a href="libvirt-libvirt-stream.html#virStreamSourceHoleFunc">virStreamSourceHoleFunc</a></span> holeHandler, <br/>					 <span class="type"><a href="libvirt-libvirt-stream.html#virStreamSourceSkipFunc">virStreamSourceSkipFunc</a></span> skipHandler, <br/>					 <span class="type">void *</span> opaque)
</pre>
        <h2>Description</h2>
        <h3>
          <a name="types">Types</a>
        </h3>
        <h3>
          <a name="virStreamEventType">
            <code>virStreamEventType</code>
          </a>
        </h3>
        <div class="api">
          <pre><span class="keyword">enum</span> virStreamEventType {
</pre>
          <table>
            <tr>
              <td>
                <a name="VIR_STREAM_EVENT_READABLE">VIR_STREAM_EVENT_READABLE</a>
              </td>
              <td> = </td>
              <td colspan="2" class="enumvalue">1 (0x1; 1 &lt;&lt; 0)</td>
            </tr>
            <tr>
              <td>
                <a name="VIR_STREAM_EVENT_WRITABLE">VIR_STREAM_EVENT_WRITABLE</a>
              </td>
              <td> = </td>
              <td colspan="2" class="enumvalue">2 (0x2; 1 &lt;&lt; 1)</td>
            </tr>
            <tr>
              <td>
                <a name="VIR_STREAM_EVENT_ERROR">VIR_STREAM_EVENT_ERROR</a>
              </td>
              <td> = </td>
              <td colspan="2" class="enumvalue">4 (0x4; 1 &lt;&lt; 2)</td>
            </tr>
            <tr>
              <td>
                <a name="VIR_STREAM_EVENT_HANGUP">VIR_STREAM_EVENT_HANGUP</a>
              </td>
              <td> = </td>
              <td colspan="2" class="enumvalue">8 (0x8; 1 &lt;&lt; 3)</td>
            </tr>
          </table>
          <pre>}
</pre>
        </div>
        <h3>
          <a name="virStreamFlags">
            <code>virStreamFlags</code>
          </a>
        </h3>
        <div class="api">
          <pre><span class="keyword">enum</span> virStreamFlags {
</pre>
          <table>
            <tr>
              <td>
                <a name="VIR_STREAM_NONBLOCK">VIR_STREAM_NONBLOCK</a>
              </td>
              <td> = </td>
              <td colspan="2" class="enumvalue">1 (0x1; 1 &lt;&lt; 0)</td>
            </tr>
          </table>
          <pre>}
</pre>
        </div>
        <h3>
          <a name="virStreamRecvFlagsValues">
            <code>virStreamRecvFlagsValues</code>
          </a>
        </h3>
        <div class="api">
          <pre><span class="keyword">enum</span> virStreamRecvFlagsValues {
</pre>
          <table>
            <tr>
              <td>
                <a name="VIR_STREAM_RECV_STOP_AT_HOLE">VIR_STREAM_RECV_STOP_AT_HOLE</a>
              </td>
              <td> = </td>
              <td colspan="2" class="enumvalue">1 (0x1; 1 &lt;&lt; 0)</td>
            </tr>
          </table>
          <pre>}
</pre>
        </div>
        <h3>
          <a name="functions">Functions</a>
        </h3>
        <h3>
          <a name="virStreamAbort">
            <code>virStreamAbort</code>
          </a>
        </h3>
        <pre class="api"><span class="type">int</span>	virStreamAbort			(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream)</pre>
        <div class="description">
          <p>Request that the in progress data transfer be cancelled abnormally before the end of the stream has been reached. For output streams this can be used to inform the driver that the stream is being terminated early. For input streams this can be used to inform the driver that it should stop sending data.</p>
          <p>If the stream is non-blocking, any callback must be removed beforehand.</p>
        </div>
        <dl class="variablelist">
          <dt>stream</dt>
          <dd>pointer to the stream object</dd>
          <dt>Returns</dt>
          <dd>0 on success, -1 upon error</dd>
        </dl>
        <div class="acl"/>
        <h3>
          <a name="virStreamEventAddCallback">
            <code>virStreamEventAddCallback</code>
          </a>
        </h3>
        <pre class="api"><span class="type">int</span>	virStreamEventAddCallback	(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream,
					 <span class="type">int</span> events,
					 <span class="type"><a href="libvirt-libvirt-stream.html#virStreamEventCallback">virStreamEventCallback</a></span> cb,
					 <span class="type">void *</span> opaque,
					 <span class="type"><a href="libvirt-libvirt-common.html#virFreeCallback">virFreeCallback</a></span> ff)</pre>
        <div class="description">
          <p>Register a callback to be notified when a stream becomes writable, or readable. This is most commonly used in conjunction with non-blocking data streams to integrate into an event loop</p>
        </div>
        <dl class="variablelist">
          <dt>stream</dt>
          <dd>pointer to the stream object</dd>
          <dt>events</dt>
          <dd>set of events to monitor</dd>
          <dt>cb</dt>
          <dd>callback to invoke when an event occurs</dd>
          <dt>opaque</dt>
          <dd>application defined data</dd>
          <dt>ff</dt>
          <dd>callback to free @opaque data</dd>
          <dt>Returns</dt>
          <dd>0 on success, -1 upon error</dd>
        </dl>
        <div class="acl"/>
        <h3>
          <a name="virStreamEventCallback">
            <code>virStreamEventCallback</code>
          </a>
        </h3>
        <pre class="api"><span class="keyword">typedef</span> <span class="type">void</span>	(*virStreamEventCallback	)	(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream,
					 <span class="type">int</span> events,
					 <span class="type">void *</span> opaque)
</pre>
        <div class="description">
          <p>Callback for receiving stream events. The callback will be invoked once for each event which is pending.</p>
        </div>
        <dl class="variablelist">
          <dt>stream</dt>
          <dd>stream on which the event occurred</dd>
          <dt>events</dt>
          <dd>bitset of events from <a href="libvirt-libvirt-event.html#virEventHandleType">virEventHandleType</a> constants</dd>
          <dt>opaque</dt>
          <dd>user data registered with handle</dd>
        </dl>
        <br/>
        <h3>
          <a name="virStreamEventRemoveCallback">
            <code>virStreamEventRemoveCallback</code>
          </a>
        </h3>
        <pre class="api"><span class="type">int</span>	virStreamEventRemoveCallback	(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream)</pre>
        <div class="description">
          <p>Remove an event callback from the stream</p>
        </div>
        <dl class="variablelist">
          <dt>stream</dt>
          <dd>pointer to the stream object</dd>
          <dt>Returns</dt>
          <dd>0 on success, -1 on error</dd>
        </dl>
        <div class="acl"/>
        <h3>
          <a name="virStreamEventUpdateCallback">
            <code>virStreamEventUpdateCallback</code>
          </a>
        </h3>
        <pre class="api"><span class="type">int</span>	virStreamEventUpdateCallback	(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream,
					 <span class="type">int</span> events)</pre>
        <div class="description">
          <p>Changes the set of events to monitor for a stream. This allows for event notification to be changed without having to unregister &amp; register the callback completely. This method is guaranteed to succeed if a callback is already registered</p>
        </div>
        <dl class="variablelist">
          <dt>stream</dt>
          <dd>pointer to the stream object</dd>
          <dt>events</dt>
          <dd>set of events to monitor</dd>
          <dt>Returns</dt>
          <dd>0 on success, -1 if no callback is registered</dd>
        </dl>
        <div class="acl"/>
        <h3>
          <a name="virStreamFinish">
            <code>virStreamFinish</code>
          </a>
        </h3>
        <pre class="api"><span class="type">int</span>	virStreamFinish			(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream)</pre>
        <div class="description">
          <p>Indicate that there is no further data to be transmitted on the stream. For output streams this should be called once all data has been written. For input streams this should be called once <a href="libvirt-libvirt-stream.html#virStreamRecv">virStreamRecv</a> returns end-of-file.</p>
          <p>This method is a synchronization point for all asynchronous errors, so if this returns a success code the application can be sure that all data has been successfully processed.</p>
          <p>If the stream is non-blocking, any callback must be removed beforehand.</p>
        </div>
        <dl class="variablelist">
          <dt>stream</dt>
          <dd>pointer to the stream object</dd>
          <dt>Returns</dt>
          <dd>0 on success, -1 upon error</dd>
        </dl>
        <div class="acl"/>
        <h3>
          <a name="virStreamFree">
            <code>virStreamFree</code>
          </a>
        </h3>
        <pre class="api"><span class="type">int</span>	virStreamFree			(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream)</pre>
        <div class="description">
          <p>Decrement the reference count on a stream, releasing the stream object if the reference count has hit zero.</p>
          <p>There must not be an active data transfer in progress when releasing the stream. If a stream needs to be disposed of prior to end of stream being reached, then the <a href="libvirt-libvirt-stream.html#virStreamAbort">virStreamAbort</a> function should be called first.</p>
        </div>
        <dl class="variablelist">
          <dt>stream</dt>
          <dd>pointer to the stream object</dd>
          <dt>Returns</dt>
          <dd>0 upon success, or -1 on error</dd>
        </dl>
        <div class="acl"/>
        <h3>
          <a name="virStreamNew">
            <code>virStreamNew</code>
          </a>
        </h3>
        <pre class="api"><span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span>	virStreamNew		(<span class="type"><a href="libvirt-libvirt-host.html#virConnectPtr">virConnectPtr</a></span> conn,
					 <span class="type">unsigned int</span> flags)</pre>
        <div class="description">
          <p>Creates a new stream object which can be used to perform streamed I/O with other public API function.</p>
          <p>When no longer needed, a stream object must be released with <a href="libvirt-libvirt-stream.html#virStreamFree">virStreamFree</a>. If a data stream has been used, then the application must call <a href="libvirt-libvirt-stream.html#virStreamFinish">virStreamFinish</a> or <a href="libvirt-libvirt-stream.html#virStreamAbort">virStreamAbort</a> before free'ing to, in order to notify the driver of termination.</p>
          <p>If a non-blocking data stream is required passed <a href="libvirt-libvirt-stream.html#VIR_STREAM_NONBLOCK">VIR_STREAM_NONBLOCK</a> for flags, otherwise pass 0.</p>
        </div>
        <dl class="variablelist">
          <dt>conn</dt>
          <dd>pointer to the connection</dd>
          <dt>flags</dt>
          <dd>bitwise-OR of <a href="libvirt-libvirt-stream.html#virStreamFlags">virStreamFlags</a></dd>
          <dt>Returns</dt>
          <dd>the new stream, or NULL upon error</dd>
        </dl>
        <div class="acl"/>
        <h3>
          <a name="virStreamRecv">
            <code>virStreamRecv</code>
          </a>
        </h3>
        <pre class="api"><span class="type">int</span>	virStreamRecv			(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream,
					 <span class="type">char *</span> data,
					 <span class="type">size_t</span> nbytes)</pre>
        <div class="description">
          <p>Reads a series of bytes from the stream. This method may block the calling application for an arbitrary amount of time.</p>
          <p>Errors are not guaranteed to be reported synchronously with the call, but may instead be delayed until a subsequent call.</p>
          <p>An example using this with a hypothetical file download API looks like</p>
          <pre class="code">  virStreamPtr st = virStreamNew(conn, 0);
  int fd = open("demo.iso", O_WRONLY, 0600);

  virConnectDownloadFile(conn, "demo.iso", st);

  while (1) {
      char buf[1024];
      int got = virStreamRecv(st, buf, 1024);
      if (got &lt; 0) {
         virStreamAbort(st);
         break;
      }
      if (got == 0) {
         virStreamFinish(st);
         break;
      }
      int offset = 0;
      while (offset &lt; got) {
         int sent = write(fd, buf + offset, got - offset);
         if (sent &lt; 0) {
            virStreamAbort(st);
            goto done;
         }
         offset += sent;
      }
  }
  if (virStreamFinish(st) &lt; 0)
     ... report an error ....
done:
  virStreamFree(st);
  close(fd);</pre>
        </div>
        <dl class="variablelist">
          <dt>stream</dt>
          <dd>pointer to the stream object</dd>
          <dt>data</dt>
          <dd>buffer to read into from stream</dd>
          <dt>nbytes</dt>
          <dd>size of @data buffer</dd>
          <dt>Returns</dt>
          <dd>the number of bytes read, which may be less than requested. Returns 0 when the end of the stream is reached, at which time the caller should invoke <a href="libvirt-libvirt-stream.html#virStreamFinish">virStreamFinish</a>() to get confirmation of stream completion. Returns -1 upon error, at which time the stream will be marked as aborted, and the caller should now release the stream with <a href="libvirt-libvirt-stream.html#virStreamFree">virStreamFree</a>. Returns -2 if there is no data pending to be read &amp; the stream is marked as non-blocking.</dd>
        </dl>
        <div class="acl"/>
        <h3>
          <a name="virStreamRecvAll">
            <code>virStreamRecvAll</code>
          </a>
        </h3>
        <pre class="api"><span class="type">int</span>	virStreamRecvAll		(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream,
					 <span class="type"><a href="libvirt-libvirt-stream.html#virStreamSinkFunc">virStreamSinkFunc</a></span> handler,
					 <span class="type">void *</span> opaque)</pre>
        <div class="description">
          <p>Receive the entire data stream, sending the data to the requested data sink. This is simply a convenient alternative to <a href="libvirt-libvirt-stream.html#virStreamRecv">virStreamRecv</a>, for apps that do blocking-I/O.</p>
          <p>An example using this with a hypothetical file download API looks like</p>
          <pre class="code">int mysink(virStreamPtr st, const char *buf, int nbytes, void *opaque) {
    int *fd = opaque;

    return write(*fd, buf, nbytes);
}

virStreamPtr st = virStreamNew(conn, 0);
int fd = open("demo.iso", O_WRONLY);

virConnectUploadFile(conn, st);
if (virStreamRecvAll(st, mysink, &amp;fd) &lt; 0) {
   ...report an error ...
   goto done;
}
if (virStreamFinish(st) &lt; 0)
   ...report an error...
virStreamFree(st);
close(fd);</pre>
        </div>
        <dl class="variablelist">
          <dt>stream</dt>
          <dd>pointer to the stream object</dd>
          <dt>handler</dt>
          <dd>sink callback for writing data to application</dd>
          <dt>opaque</dt>
          <dd>application defined data</dd>
          <dt>Returns</dt>
          <dd>0 if all the data was successfully received. The caller should invoke virStreamFinish(st) to flush the stream upon success and then <a href="libvirt-libvirt-stream.html#virStreamFree">virStreamFree</a> Returns -1 upon any error, with <a href="libvirt-libvirt-stream.html#virStreamAbort">virStreamAbort</a>() already having been called, so the caller need only call <a href="libvirt-libvirt-stream.html#virStreamFree">virStreamFree</a>()</dd>
        </dl>
        <div class="acl"/>
        <h3>
          <a name="virStreamRecvFlags">
            <code>virStreamRecvFlags</code>
          </a>
        </h3>
        <pre class="api"><span class="type">int</span>	virStreamRecvFlags		(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream,
					 <span class="type">char *</span> data,
					 <span class="type">size_t</span> nbytes,
					 <span class="type">unsigned int</span> flags)</pre>
        <div class="description">
          <p>Reads a series of bytes from the stream. This method may block the calling application for an arbitrary amount of time.</p>
          <p>This is just like <a href="libvirt-libvirt-stream.html#virStreamRecv">virStreamRecv</a> except this one has extra @flags. Calling this function with no @flags set (equal to zero) is equivalent to calling virStreamRecv(stream, data, nbytes).</p>
          <p>If flag <a href="libvirt-libvirt-stream.html#VIR_STREAM_RECV_STOP_AT_HOLE">VIR_STREAM_RECV_STOP_AT_HOLE</a> is set, this function will stop reading from stream if it has reached a hole. In that case, -3 is returned and <a href="libvirt-libvirt-stream.html#virStreamRecvHole">virStreamRecvHole</a>() should be called to get the hole size. An example using this flag might look like this:</p>
          <pre class="code">while (1) {
  char buf[4096];

  int ret = virStreamRecvFlags(st, buf, len, VIR_STREAM_STOP_AT_HOLE);
  if (ret &lt; 0) {
    if (ret == -3) {
      long long len;
      ret = virStreamRecvHole(st, &amp;len, 0);
      if (ret &lt; 0) {
        ...error..
      } else {
        ...seek len bytes in target...
      }
    } else {
      return -1;
    }
  } else {
      ...write buf to target...
  }
}</pre>
        </div>
        <dl class="variablelist">
          <dt>stream</dt>
          <dd>pointer to the stream object</dd>
          <dt>data</dt>
          <dd>buffer to read into from stream</dd>
          <dt>nbytes</dt>
          <dd>size of @data buffer</dd>
          <dt>flags</dt>
          <dd>bitwise-OR of <a href="libvirt-libvirt-stream.html#virStreamRecvFlagsValues">virStreamRecvFlagsValues</a></dd>
          <dt>Returns</dt>
          <dd>0 when the end of the stream is reached, at which time the caller should invoke <a href="libvirt-libvirt-stream.html#virStreamFinish">virStreamFinish</a>() to get confirmation of stream completion. Returns -1 upon error, at which time the stream will be marked as aborted, and the caller should now release the stream with <a href="libvirt-libvirt-stream.html#virStreamFree">virStreamFree</a>. Returns -2 if there is no data pending to be read &amp; the stream is marked as non-blocking. Returns -3 if there is a hole in stream and caller requested to stop at a hole.</dd>
        </dl>
        <div class="acl"/>
        <h3>
          <a name="virStreamRecvHole">
            <code>virStreamRecvHole</code>
          </a>
        </h3>
        <pre class="api"><span class="type">int</span>	virStreamRecvHole		(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream,
					 <span class="type">long long *</span> length,
					 <span class="type">unsigned int</span> flags)</pre>
        <div class="description">
          <p>This API is used to determine the @length in bytes of the empty space to be created in a @stream's target file when uploading or downloading sparsely populated files. This is the counterpart to <a href="libvirt-libvirt-stream.html#virStreamSendHole">virStreamSendHole</a>().</p>
        </div>
        <dl class="variablelist">
          <dt>stream</dt>
          <dd>pointer to the stream object</dd>
          <dt>length</dt>
          <dd>number of bytes to skip</dd>
          <dt>flags</dt>
          <dd>extra flags; not used yet, so callers should always pass 0</dd>
          <dt>Returns</dt>
          <dd>0 on success, -1 on error or when there's currently no hole in the stream</dd>
        </dl>
        <div class="acl"/>
        <h3>
          <a name="virStreamRef">
            <code>virStreamRef</code>
          </a>
        </h3>
        <pre class="api"><span class="type">int</span>	virStreamRef			(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream)</pre>
        <div class="description">
          <p>Increment the reference count on the stream. For each additional call to this method, there shall be a corresponding call to <a href="libvirt-libvirt-stream.html#virStreamFree">virStreamFree</a> to release the reference count, once the caller no longer needs the reference to this object.</p>
        </div>
        <dl class="variablelist">
          <dt>stream</dt>
          <dd>pointer to the stream</dd>
          <dt>Returns</dt>
          <dd>0 in case of success, -1 in case of failure</dd>
        </dl>
        <div class="acl"/>
        <h3>
          <a name="virStreamSend">
            <code>virStreamSend</code>
          </a>
        </h3>
        <pre class="api"><span class="type">int</span>	virStreamSend			(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream,
					 <span class="type">const char *</span> data,
					 <span class="type">size_t</span> nbytes)</pre>
        <div class="description">
          <p>Write a series of bytes to the stream. This method may block the calling application for an arbitrary amount of time. Once an application has finished sending data it should call <a href="libvirt-libvirt-stream.html#virStreamFinish">virStreamFinish</a> to wait for successful confirmation from the driver, or detect any error.</p>
          <p>This method may not be used if a stream source has been registered.</p>
          <p>Errors are not guaranteed to be reported synchronously with the call, but may instead be delayed until a subsequent call.</p>
          <p>An example using this with a hypothetical file upload API looks like</p>
          <pre class="code">  virStreamPtr st = virStreamNew(conn, 0);
  int fd = open("demo.iso", O_RDONLY);

  virConnectUploadFile(conn, "demo.iso", st);

  while (1) {
       char buf[1024];
       int got = read(fd, buf, 1024);
       if (got &lt; 0) {
          virStreamAbort(st);
          break;
       }
       if (got == 0) {
          virStreamFinish(st);
          break;
       }
       int offset = 0;
       while (offset &lt; got) {
          int sent = virStreamSend(st, buf+offset, got-offset);
          if (sent &lt; 0) {
             virStreamAbort(st);
             goto done;
          }
          offset += sent;
       }
   }
   if (virStreamFinish(st) &lt; 0)
      ... report an error ....
 done:
   virStreamFree(st);
   close(fd);</pre>
        </div>
        <dl class="variablelist">
          <dt>stream</dt>
          <dd>pointer to the stream object</dd>
          <dt>data</dt>
          <dd>buffer to write to stream</dd>
          <dt>nbytes</dt>
          <dd>size of @data buffer</dd>
          <dt>Returns</dt>
          <dd>the number of bytes written, which may be less than requested. Returns -1 upon error, at which time the stream will be marked as aborted, and the caller should now release the stream with <a href="libvirt-libvirt-stream.html#virStreamFree">virStreamFree</a>. Returns -2 if the outgoing transmit buffers are full &amp; the stream is marked as non-blocking.</dd>
        </dl>
        <div class="acl"/>
        <h3>
          <a name="virStreamSendAll">
            <code>virStreamSendAll</code>
          </a>
        </h3>
        <pre class="api"><span class="type">int</span>	virStreamSendAll		(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream,
					 <span class="type"><a href="libvirt-libvirt-stream.html#virStreamSourceFunc">virStreamSourceFunc</a></span> handler,
					 <span class="type">void *</span> opaque)</pre>
        <div class="description">
          <p>Send the entire data stream, reading the data from the requested data source. This is simply a convenient alternative to <a href="libvirt-libvirt-stream.html#virStreamSend">virStreamSend</a>, for apps that do blocking-I/O.</p>
          <p>An example using this with a hypothetical file upload API looks like</p>
          <pre class="code">int mysource(virStreamPtr st, char *buf, int nbytes, void *opaque) {
    int *fd = opaque;

    return read(*fd, buf, nbytes);
}

virStreamPtr st = virStreamNew(conn, 0);
int fd = open("demo.iso", O_RDONLY);

virConnectUploadFile(conn, st);
if (virStreamSendAll(st, mysource, &amp;fd) &lt; 0) {
   ...report an error ...
   goto done;
}
if (virStreamFinish(st) &lt; 0)
   ...report an error...
virStreamFree(st);
close(fd);</pre>
        </div>
        <dl class="variablelist">
          <dt>stream</dt>
          <dd>pointer to the stream object</dd>
          <dt>handler</dt>
          <dd>source callback for reading data from application</dd>
          <dt>opaque</dt>
          <dd>application defined data</dd>
          <dt>Returns</dt>
          <dd>0 if all the data was successfully sent. The caller should invoke virStreamFinish(st) to flush the stream upon success and then <a href="libvirt-libvirt-stream.html#virStreamFree">virStreamFree</a> Returns -1 upon any error, with <a href="libvirt-libvirt-stream.html#virStreamAbort">virStreamAbort</a>() already having been called, so the caller need only call <a href="libvirt-libvirt-stream.html#virStreamFree">virStreamFree</a>().</dd>
        </dl>
        <div class="acl"/>
        <h3>
          <a name="virStreamSendHole">
            <code>virStreamSendHole</code>
          </a>
        </h3>
        <pre class="api"><span class="type">int</span>	virStreamSendHole		(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream,
					 <span class="type">long long</span> length,
					 <span class="type">unsigned int</span> flags)</pre>
        <div class="description">
          <p>Rather than transmitting empty file space, this API directs the @stream target to create @length bytes of empty space. This API would be used when uploading or downloading sparsely populated files to avoid the needless copy of empty file space.</p>
          <p>An example using this with a hypothetical file upload API looks like:</p>
          <pre class="code">virStream st;

while (1) {
  char buf[4096];
  size_t len;
  if (..in hole...) {
    ..get hole size...
    virStreamSendHole(st, len, 0);
  } else {
    ...read len bytes...
    virStreamSend(st, buf, len);
  }
}</pre>
        </div>
        <dl class="variablelist">
          <dt>stream</dt>
          <dd>pointer to the stream object</dd>
          <dt>length</dt>
          <dd>number of bytes to skip</dd>
          <dt>flags</dt>
          <dd>extra flags; not used yet, so callers should always pass 0</dd>
          <dt>Returns</dt>
          <dd>0 on success, -1 error</dd>
        </dl>
        <div class="acl"/>
        <h3>
          <a name="virStreamSinkFunc">
            <code>virStreamSinkFunc</code>
          </a>
        </h3>
        <pre class="api"><span class="keyword">typedef</span> <span class="type">int</span>	(*virStreamSinkFunc	)	(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> st,
					 <span class="type">const char *</span> data,
					 <span class="type">size_t</span> nbytes,
					 <span class="type">void *</span> opaque)
</pre>
        <div class="description">
          <p>The <a href="libvirt-libvirt-stream.html#virStreamSinkFunc">virStreamSinkFunc</a> callback is used together with the <a href="libvirt-libvirt-stream.html#virStreamRecvAll">virStreamRecvAll</a> or <a href="libvirt-libvirt-stream.html#virStreamSparseRecvAll">virStreamSparseRecvAll</a> functions for libvirt to provide the data that has been received.</p>
          <p>The callback will be invoked multiple times, providing data in small chunks. The application should consume up 'nbytes' from the 'data' array of data and then return the number actual number of bytes consumed. The callback will continue to be invoked until it indicates the end of the stream has been reached. A return value of -1 at any time will abort the receive operation</p>
          <p>Please note that for more accurate error reporting the callback should set appropriate errno on failure.</p>
        </div>
        <dl class="variablelist">
          <dt>st</dt>
          <dd>the stream object</dd>
          <dt>data</dt>
          <dd>preallocated array to be filled with data</dd>
          <dt>nbytes</dt>
          <dd>size of the data array</dd>
          <dt>opaque</dt>
          <dd>optional application provided data</dd>
          <dt>Returns</dt>
          <dd>the number of bytes consumed or -1 upon error</dd>
        </dl>
        <br/>
        <h3>
          <a name="virStreamSinkHoleFunc">
            <code>virStreamSinkHoleFunc</code>
          </a>
        </h3>
        <pre class="api"><span class="keyword">typedef</span> <span class="type">int</span>	(*virStreamSinkHoleFunc	)	(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> st,
					 <span class="type">long long</span> length,
					 <span class="type">void *</span> opaque)
</pre>
        <div class="description">
          <p>This callback is used together with the <a href="libvirt-libvirt-stream.html#virStreamSparseRecvAll">virStreamSparseRecvAll</a> function for libvirt to provide the size of a hole that occurred in the stream.</p>
          <p>The callback may be invoked multiple times as holes are found during processing a stream. The application should create the hole in the stream target and then return. A return value of -1 at any time will abort the receive operation.</p>
          <p>Please note that for more accurate error reporting the callback should set appropriate errno on failure.</p>
        </div>
        <dl class="variablelist">
          <dt>st</dt>
          <dd>the stream object</dd>
          <dt>length</dt>
          <dd>stream hole size</dd>
          <dt>opaque</dt>
          <dd>optional application provided data</dd>
          <dt>Returns</dt>
          <dd>0 on success, -1 upon error</dd>
        </dl>
        <br/>
        <h3>
          <a name="virStreamSourceFunc">
            <code>virStreamSourceFunc</code>
          </a>
        </h3>
        <pre class="api"><span class="keyword">typedef</span> <span class="type">int</span>	(*virStreamSourceFunc	)	(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> st,
					 <span class="type">char *</span> data,
					 <span class="type">size_t</span> nbytes,
					 <span class="type">void *</span> opaque)
</pre>
        <div class="description">
          <p>The <a href="libvirt-libvirt-stream.html#virStreamSourceFunc">virStreamSourceFunc</a> callback is used together with the <a href="libvirt-libvirt-stream.html#virStreamSendAll">virStreamSendAll</a> and <a href="libvirt-libvirt-stream.html#virStreamSparseSendAll">virStreamSparseSendAll</a> functions for libvirt to obtain the data that is to be sent.</p>
          <p>The callback will be invoked multiple times, fetching data in small chunks. The application should fill the 'data' array with up to 'nbytes' of data and then return the number actual number of bytes. The callback will continue to be invoked until it indicates the end of the source has been reached by returning 0. A return value of -1 at any time will abort the send operation.</p>
          <p>Please note that for more accurate error reporting the callback should set appropriate errno on failure.</p>
        </div>
        <dl class="variablelist">
          <dt>st</dt>
          <dd>the stream object</dd>
          <dt>data</dt>
          <dd>preallocated array to be filled with data</dd>
          <dt>nbytes</dt>
          <dd>size of the data array</dd>
          <dt>opaque</dt>
          <dd>optional application provided data</dd>
          <dt>Returns</dt>
          <dd>the number of bytes filled, 0 upon end of file, or -1 upon error</dd>
        </dl>
        <br/>
        <h3>
          <a name="virStreamSourceHoleFunc">
            <code>virStreamSourceHoleFunc</code>
          </a>
        </h3>
        <pre class="api"><span class="keyword">typedef</span> <span class="type">int</span>	(*virStreamSourceHoleFunc	)	(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> st,
					 <span class="type">int *</span> inData,
					 <span class="type">long long *</span> length,
					 <span class="type">void *</span> opaque)
</pre>
        <div class="description">
          <p>The <a href="libvirt-libvirt-stream.html#virStreamSourceHoleFunc">virStreamSourceHoleFunc</a> callback is used together with the <a href="libvirt-libvirt-stream.html#virStreamSparseSendAll">virStreamSparseSendAll</a> function for libvirt to obtain the length of section stream is currently in.</p>
          <p>Moreover, upon successful return, @length should be updated with how many bytes are left until the current section ends (either data section or hole section). Also the stream is currently in data section, @inData should be set to a non-zero value and vice versa.</p>
          <p>NB: there's an implicit hole at the end of each file. If that's the case, @inData and @length should be both set to 0.</p>
          <p>This function should not adjust the current position within the file.</p>
          <p>Please note that for more accurate error reporting the callback should set appropriate errno on failure.</p>
        </div>
        <dl class="variablelist">
          <dt>st</dt>
          <dd>the stream object</dd>
          <dt>inData</dt>
          <dd>are we in data section</dd>
          <dt>length</dt>
          <dd>how long is the section we are currently in</dd>
          <dt>opaque</dt>
          <dd>optional application provided data</dd>
          <dt>Returns</dt>
          <dd>0 on success, -1 upon error</dd>
        </dl>
        <br/>
        <h3>
          <a name="virStreamSourceSkipFunc">
            <code>virStreamSourceSkipFunc</code>
          </a>
        </h3>
        <pre class="api"><span class="keyword">typedef</span> <span class="type">int</span>	(*virStreamSourceSkipFunc	)	(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> st,
					 <span class="type">long long</span> length,
					 <span class="type">void *</span> opaque)
</pre>
        <div class="description">
          <p>This callback is used together with the <a href="libvirt-libvirt-stream.html#virStreamSparseSendAll">virStreamSparseSendAll</a> to skip holes in the underlying file as reported by <a href="libvirt-libvirt-stream.html#virStreamSourceHoleFunc">virStreamSourceHoleFunc</a>.</p>
          <p>The callback may be invoked multiple times as holes are found during processing a stream. The application should skip processing the hole in the stream source and then return. A return value of -1 at any time will abort the send operation.</p>
          <p>Please note that for more accurate error reporting the callback should set appropriate errno on failure.</p>
        </div>
        <dl class="variablelist">
          <dt>st</dt>
          <dd>the stream object</dd>
          <dt>length</dt>
          <dd>stream hole size</dd>
          <dt>opaque</dt>
          <dd>optional application provided data</dd>
          <dt>Returns</dt>
          <dd>0 on success, -1 upon error.</dd>
        </dl>
        <br/>
        <h3>
          <a name="virStreamSparseRecvAll">
            <code>virStreamSparseRecvAll</code>
          </a>
        </h3>
        <pre class="api"><span class="type">int</span>	virStreamSparseRecvAll		(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream,
					 <span class="type"><a href="libvirt-libvirt-stream.html#virStreamSinkFunc">virStreamSinkFunc</a></span> handler,
					 <span class="type"><a href="libvirt-libvirt-stream.html#virStreamSinkHoleFunc">virStreamSinkHoleFunc</a></span> holeHandler,
					 <span class="type">void *</span> opaque)</pre>
        <div class="description">
          <p>Receive the entire data stream, sending the data to the requested data sink @handler and calling the skip @holeHandler to generate holes for sparse stream targets. This is simply a convenient alternative to <a href="libvirt-libvirt-stream.html#virStreamRecvFlags">virStreamRecvFlags</a>, for apps that do blocking-I/O.</p>
          <p>An example using this with a hypothetical file download API looks like:</p>
          <pre class="code">int mysink(virStreamPtr st, const char *buf, int nbytes, void *opaque) {
    int *fd = opaque;

    return write(*fd, buf, nbytes);
}

int myskip(virStreamPtr st, long long offset, void *opaque) {
    int *fd = opaque;

    return lseek(*fd, offset, SEEK_CUR) == (off_t) -1 ? -1 : 0;
}

virStreamPtr st = virStreamNew(conn, 0);
int fd = open("demo.iso", O_WRONLY);

virConnectDownloadSparseFile(conn, st);
if (virStreamSparseRecvAll(st, mysink, myskip, &amp;fd) &lt; 0) {
   ...report an error ...
   goto done;
}
if (virStreamFinish(st) &lt; 0)
   ...report an error...
virStreamFree(st);
close(fd);</pre>
          <p>Note that @opaque data is shared between both @handler and @holeHandler callbacks.</p>
        </div>
        <dl class="variablelist">
          <dt>stream</dt>
          <dd>pointer to the stream object</dd>
          <dt>handler</dt>
          <dd>sink callback for writing data to application</dd>
          <dt>holeHandler</dt>
          <dd>stream hole callback for skipping holes</dd>
          <dt>opaque</dt>
          <dd>application defined data</dd>
          <dt>Returns</dt>
          <dd>0 if all the data was successfully received. The caller should invoke virStreamFinish(st) to flush the stream upon success and then virStreamFree(st). Returns -1 upon any error, with <a href="libvirt-libvirt-stream.html#virStreamAbort">virStreamAbort</a>() already having been called, so the caller need only call <a href="libvirt-libvirt-stream.html#virStreamFree">virStreamFree</a>().</dd>
        </dl>
        <div class="acl"/>
        <h3>
          <a name="virStreamSparseSendAll">
            <code>virStreamSparseSendAll</code>
          </a>
        </h3>
        <pre class="api"><span class="type">int</span>	virStreamSparseSendAll		(<span class="type"><a href="libvirt-libvirt-host.html#virStreamPtr">virStreamPtr</a></span> stream,
					 <span class="type"><a href="libvirt-libvirt-stream.html#virStreamSourceFunc">virStreamSourceFunc</a></span> handler,
					 <span class="type"><a href="libvirt-libvirt-stream.html#virStreamSourceHoleFunc">virStreamSourceHoleFunc</a></span> holeHandler,
					 <span class="type"><a href="libvirt-libvirt-stream.html#virStreamSourceSkipFunc">virStreamSourceSkipFunc</a></span> skipHandler,
					 <span class="type">void *</span> opaque)</pre>
        <div class="description">
          <p>Send the entire data stream, reading the data from the requested data source. This is simply a convenient alternative to <a href="libvirt-libvirt-stream.html#virStreamSend">virStreamSend</a>, for apps that do blocking-I/O.</p>
          <p>An example using this with a hypothetical file upload API looks like</p>
          <pre class="code">int mysource(virStreamPtr st, char *buf, int nbytes, void *opaque) {
    int *fd = opaque;

    return read(*fd, buf, nbytes);
}

int myskip(virStreamPtr st, long long offset, void *opaque) {
    int *fd = opaque;

    return lseek(*fd, offset, SEEK_CUR) == (off_t) -1 ? -1 : 0;
}

int myindata(virStreamPtr st, int *inData,
             long long *offset, void *opaque) {
    int *fd = opaque;

    if (@fd in hole) {
        *inData = 0;
        *offset = holeSize;
    } else {
        *inData = 1;
        *offset = dataSize;
    }

    return 0;
}

virStreamPtr st = virStreamNew(conn, 0);
int fd = open("demo.iso", O_RDONLY);

virConnectUploadSparseFile(conn, st);
if (virStreamSparseSendAll(st,
                           mysource,
                           myindata,
                           myskip,
                           &amp;fd) &lt; 0) {
   ...report an error ...
   goto done;
}
if (virStreamFinish(st) &lt; 0)
   ...report an error...
virStreamFree(st);
close(fd);</pre>
          <p>Note that @opaque data are shared between @handler, @holeHandler and @skipHandler.</p>
        </div>
        <dl class="variablelist">
          <dt>stream</dt>
          <dd>pointer to the stream object</dd>
          <dt>handler</dt>
          <dd>source callback for reading data from application</dd>
          <dt>holeHandler</dt>
          <dd>source callback for determining holes</dd>
          <dt>skipHandler</dt>
          <dd>skip holes as reported by @holeHandler</dd>
          <dt>opaque</dt>
          <dd>application defined data</dd>
          <dt>Returns</dt>
          <dd>0 if all the data was successfully sent. The caller should invoke virStreamFinish(st) to flush the stream upon success and then <a href="libvirt-libvirt-stream.html#virStreamFree">virStreamFree</a>. Returns -1 upon any error, with <a href="libvirt-libvirt-stream.html#virStreamAbort">virStreamAbort</a>() already having been called, so the caller need only call <a href="libvirt-libvirt-stream.html#virStreamFree">virStreamFree</a>().</dd>
        </dl>
        <div class="acl"/>
      </div>
    </div>
    <div id="nav">
      <div id="home">
        <a href="../index.html">Home</a>
      </div>
      <div id="jumplinks">
        <ul>
          <li>
            <a href="../downloads.html">Download</a>
          </li>
          <li>
            <a href="../contribute.html">Contribute</a>
          </li>
          <li>
            <a href="../docs.html">Docs</a>
          </li>
        </ul>
      </div>
      <div id="search">
        <form action="../search.php" enctype="application/x-www-form-urlencoded" method="get">
          <div>
            <input name="query" type="text" size="12" value=""/>
            <input name="submit" type="submit" value="Go"/>
          </div>
        </form>
      </div>
    </div>
    <div id="footer">
      <div id="contact">
        <h3>Contact</h3>
        <ul>
          <li>
            <a href="../contact.html#email">email</a>
          </li>
          <li>
            <a href="../contact.html#irc">irc</a>
          </li>
        </ul>
      </div>
      <div id="community">
        <h3>Community</h3>
        <ul>
          <li>
            <a href="https://twitter.com/hashtag/libvirt">twitter</a>
          </li>
          <li>
            <a href="https://plus.google.com/communities/109522598353007505282">google+</a>
          </li>
          <li>
            <a href="http://stackoverflow.com/questions/tagged/libvirt">stackoverflow</a>
          </li>
          <li>
            <a href="http://serverfault.com/questions/tagged/libvirt">serverfault</a>
          </li>
        </ul>
      </div>
      <div id="conduct">
            Participants in the libvirt project agree to abide by <a href="../governance.html#codeofconduct">the project code of conduct</a></div>
      <br class="clear"/>
    </div>
  </body>
</html>
