<?xml version="1.0" encoding="ISO-8859-1"?>
<api name='libvirt'>
  <files>
    <file name='libvirt'>
     <summary>core interfaces for the libvirt library</summary>
     <description>Provides the interfaces of the libvirt library to handle virtualized domains </description>
     <author>Daniel Veillard &lt;veillard@redhat.com&gt; </author>
     <exports symbol='VIR_NODEINFO_MAXCPUS' type='macro'/>
     <exports symbol='LIBVIR_VERSION_NUMBER' type='macro'/>
     <exports symbol='VIR_USE_CPU' type='macro'/>
     <exports symbol='VIR_CPU_MAPLEN' type='macro'/>
     <exports symbol='VIR_UUID_BUFLEN' type='macro'/>
     <exports symbol='VIR_CPU_USABLE' type='macro'/>
     <exports symbol='VIR_COPY_CPUMAP' type='macro'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_LENGTH' type='macro'/>
     <exports symbol='VIR_UUID_STRING_BUFLEN' type='macro'/>
     <exports symbol='VIR_GET_CPUMAP' type='macro'/>
     <exports symbol='VIR_UNUSE_CPU' type='macro'/>
     <exports symbol='VIR_DOMAIN_EVENT_DEFINED' type='enum'/>
     <exports symbol='VIR_CRED_EXTERNAL' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STOPPED_CRASHED' type='enum'/>
     <exports symbol='VIR_EVENT_HANDLE_READABLE' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTDOWN' type='enum'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_UINT' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_BUILDING' type='enum'/>
     <exports symbol='VIR_CRED_CNONCE' type='enum'/>
     <exports symbol='VIR_CRED_ECHOPROMPT' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STARTED_BOOTED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_RESUMED' type='enum'/>
     <exports symbol='VIR_VCPU_OFFLINE' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_DELETE_NORMAL' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_RUNNING' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_BUILD_RESIZE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STOPPED_FAILED' type='enum'/>
     <exports symbol='VIR_CONNECT_RO' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STOPPED' type='enum'/>
     <exports symbol='VIR_CRED_AUTHNAME' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_BUILD_REPAIR' type='enum'/>
     <exports symbol='VIR_CRED_LANGUAGE' type='enum'/>
     <exports symbol='VIR_CRED_NOECHOPROMPT' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_UNDEFINED' type='enum'/>
     <exports symbol='VIR_MIGRATE_LIVE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STOPPED_DESTROYED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_DEFINED_ADDED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STARTED_MIGRATED' type='enum'/>
     <exports symbol='VIR_VCPU_BLOCKED' type='enum'/>
     <exports symbol='VIR_MEMORY_VIRTUAL' type='enum'/>
     <exports symbol='VIR_CRED_USERNAME' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_RESUMED_UNPAUSED' type='enum'/>
     <exports symbol='VIR_DOMAIN_RUNNING' type='enum'/>
     <exports symbol='VIR_EVENT_HANDLE_ERROR' type='enum'/>
     <exports symbol='VIR_DOMAIN_NOSTATE' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTOFF' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_DELETE_ZEROED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STARTED_RESTORED' type='enum'/>
     <exports symbol='VIR_EVENT_HANDLE_WRITABLE' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_BUILD_NEW' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_SUSPENDED_PAUSED' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_DELETE_NORMAL' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_DELETE_ZEROED' type='enum'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_INT' type='enum'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_ULLONG' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN' type='enum'/>
     <exports symbol='VIR_CRED_REALM' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STARTED' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_FILE' type='enum'/>
     <exports symbol='VIR_EVENT_HANDLE_HANGUP' type='enum'/>
     <exports symbol='VIR_DOMAIN_PAUSED' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_DEGRADED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_DEFINED_UPDATED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_SUSPENDED_MIGRATED' type='enum'/>
     <exports symbol='VIR_DOMAIN_CRASHED' type='enum'/>
     <exports symbol='VIR_VCPU_RUNNING' type='enum'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_DOUBLE' type='enum'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_LLONG' type='enum'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_BOOLEAN' type='enum'/>
     <exports symbol='VIR_DOMAIN_XML_INACTIVE' type='enum'/>
     <exports symbol='VIR_STORAGE_VOL_BLOCK' type='enum'/>
     <exports symbol='VIR_DOMAIN_NONE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_UNDEFINED_REMOVED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_RESUMED_MIGRATED' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCKED' type='enum'/>
     <exports symbol='VIR_CRED_PASSPHRASE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STOPPED_SAVED' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_STOPPED_MIGRATED' type='enum'/>
     <exports symbol='VIR_STORAGE_POOL_INACTIVE' type='enum'/>
     <exports symbol='VIR_DOMAIN_XML_SECURE' type='enum'/>
     <exports symbol='VIR_DOMAIN_EVENT_SUSPENDED' type='enum'/>
     <exports symbol='virDomainBlockStatsStruct' type='typedef'/>
     <exports symbol='virDomainMigrateFlags' type='typedef'/>
     <exports symbol='virNodeInfo' type='typedef'/>
     <exports symbol='virNetwork' type='typedef'/>
     <exports symbol='virDomainEventResumedDetailType' type='typedef'/>
     <exports symbol='virDomainBlockStatsPtr' type='typedef'/>
     <exports symbol='virConnect' type='typedef'/>
     <exports symbol='virDomainEventStartedDetailType' type='typedef'/>
     <exports symbol='virDomainInfo' type='typedef'/>
     <exports symbol='virStoragePoolDeleteFlags' type='typedef'/>
     <exports symbol='virEventHandleType' type='typedef'/>
     <exports symbol='virStoragePool' type='typedef'/>
     <exports symbol='virDomainEventType' type='typedef'/>
     <exports symbol='virDomainInterfaceStatsStruct' type='typedef'/>
     <exports symbol='virStoragePoolInfo' type='typedef'/>
     <exports symbol='virDomainState' type='typedef'/>
     <exports symbol='virDomain' type='typedef'/>
     <exports symbol='virDomainInterfaceStatsPtr' type='typedef'/>
     <exports symbol='virConnectAuthPtr' type='typedef'/>
     <exports symbol='virStorageVolInfo' type='typedef'/>
     <exports symbol='virSchedParameterType' type='typedef'/>
     <exports symbol='virStorageVolInfoPtr' type='typedef'/>
     <exports symbol='virConnectCredentialPtr' type='typedef'/>
     <exports symbol='virStoragePoolPtr' type='typedef'/>
     <exports symbol='virNodeInfoPtr' type='typedef'/>
     <exports symbol='virNetworkPtr' type='typedef'/>
     <exports symbol='virDomainInfoPtr' type='typedef'/>
     <exports symbol='virNodeDevice' type='typedef'/>
     <exports symbol='virConnectPtr' type='typedef'/>
     <exports symbol='virStorageVol' type='typedef'/>
     <exports symbol='virNodeDevicePtr' type='typedef'/>
     <exports symbol='virSchedParameter' type='typedef'/>
     <exports symbol='virConnectFlags' type='typedef'/>
     <exports symbol='virDomainEventDefinedDetailType' type='typedef'/>
     <exports symbol='virDomainMemoryFlags' type='typedef'/>
     <exports symbol='virDomainEventStoppedDetailType' type='typedef'/>
     <exports symbol='virStorageVolPtr' type='typedef'/>
     <exports symbol='virVcpuState' type='typedef'/>
     <exports symbol='virStorageVolDeleteFlags' type='typedef'/>
     <exports symbol='virVcpuInfo' type='typedef'/>
     <exports symbol='virSchedParameterPtr' type='typedef'/>
     <exports symbol='virConnectAuth' type='typedef'/>
     <exports symbol='virConnectCredential' type='typedef'/>
     <exports symbol='virDomainEventSuspendedDetailType' type='typedef'/>
     <exports symbol='virVcpuInfoPtr' type='typedef'/>
     <exports symbol='virStoragePoolBuildFlags' type='typedef'/>
     <exports symbol='virDomainXMLFlags' type='typedef'/>
     <exports symbol='virStorageVolType' type='typedef'/>
     <exports symbol='virDomainEventUndefinedDetailType' type='typedef'/>
     <exports symbol='virDomainPtr' type='typedef'/>
     <exports symbol='virConnectCredentialType' type='typedef'/>
     <exports symbol='virStoragePoolState' type='typedef'/>
     <exports symbol='virStoragePoolInfoPtr' type='typedef'/>
     <exports symbol='virDomainCreateFlags' type='typedef'/>
     <exports symbol='_virDomainInfo' type='struct'/>
     <exports symbol='_virConnectAuth' type='struct'/>
     <exports symbol='_virVcpuInfo' type='struct'/>
     <exports symbol='_virDomainInterfaceStats' type='struct'/>
     <exports symbol='_virStoragePoolInfo' type='struct'/>
     <exports symbol='_virConnectCredential' type='struct'/>
     <exports symbol='_virStorageVolInfo' type='struct'/>
     <exports symbol='_virDomainBlockStats' type='struct'/>
     <exports symbol='_virNodeInfo' type='struct'/>
     <exports symbol='_virSchedParameter' type='struct'/>
     <exports symbol='virConnectAuthPtrDefault' type='variable'/>
     <exports symbol='virStoragePoolGetXMLDesc' type='function'/>
     <exports symbol='virStorageVolGetKey' type='function'/>
     <exports symbol='virEventUpdateTimeoutFunc' type='function'/>
     <exports symbol='virConnectClose' type='function'/>
     <exports symbol='virDomainDefineXML' type='function'/>
     <exports symbol='virDomainShutdown' type='function'/>
     <exports symbol='virConnectListStoragePools' type='function'/>
     <exports symbol='virGetVersion' type='function'/>
     <exports symbol='virNodeGetCellsFreeMemory' type='function'/>
     <exports symbol='virInitialize' type='function'/>
     <exports symbol='virNodeDeviceGetName' type='function'/>
     <exports symbol='virStoragePoolSetAutostart' type='function'/>
     <exports symbol='virStorageVolCreateXML' type='function'/>
     <exports symbol='virConnectDomainEventDeregister' type='function'/>
     <exports symbol='virDomainGetSchedulerParameters' type='function'/>
     <exports symbol='virDomainLookupByUUIDString' type='function'/>
     <exports symbol='virConnectNumOfDefinedNetworks' type='function'/>
     <exports symbol='virConnectNumOfDomains' type='function'/>
     <exports symbol='virNetworkGetUUID' type='function'/>
     <exports symbol='virStoragePoolGetConnect' type='function'/>
     <exports symbol='virConnectGetVersion' type='function'/>
     <exports symbol='virDomainFree' type='function'/>
     <exports symbol='virStoragePoolGetName' type='function'/>
     <exports symbol='virDomainSetAutostart' type='function'/>
     <exports symbol='virStoragePoolDefineXML' type='function'/>
     <exports symbol='virStorageVolLookupByPath' type='function'/>
     <exports symbol='virStorageVolLookupByName' type='function'/>
     <exports symbol='virDomainCreateLinux' type='function'/>
     <exports symbol='virDomainSetMaxMemory' type='function'/>
     <exports symbol='virEventRegisterImpl' type='function'/>
     <exports symbol='virDomainMigrate' type='function'/>
     <exports symbol='virDomainSuspend' type='function'/>
     <exports symbol='virNetworkCreate' type='function'/>
     <exports symbol='virNodeDeviceGetXMLDesc' type='function'/>
     <exports symbol='virEventUpdateHandleFunc' type='function'/>
     <exports symbol='virDomainDestroy' type='function'/>
     <exports symbol='virConnectNumOfNetworks' type='function'/>
     <exports symbol='virStoragePoolLookupByUUIDString' type='function'/>
     <exports symbol='virDomainGetXMLDesc' type='function'/>
     <exports symbol='virStoragePoolGetUUID' type='function'/>
     <exports symbol='virNodeDeviceFree' type='function'/>
     <exports symbol='virStorageVolGetInfo' type='function'/>
     <exports symbol='virDomainGetInfo' type='function'/>
     <exports symbol='virNetworkDestroy' type='function'/>
     <exports symbol='virStoragePoolLookupByName' type='function'/>
     <exports symbol='virStoragePoolCreateXML' type='function'/>
     <exports symbol='virNetworkGetAutostart' type='function'/>
     <exports symbol='virNetworkGetBridgeName' type='function'/>
     <exports symbol='virStorageVolGetXMLDesc' type='function'/>
     <exports symbol='virDomainSetSchedulerParameters' type='function'/>
     <exports symbol='virConnectGetType' type='function'/>
     <exports symbol='virDomainSave' type='function'/>
     <exports symbol='virDomainCreate' type='function'/>
     <exports symbol='virConnectListDomains' type='function'/>
     <exports symbol='virDomainCoreDump' type='function'/>
     <exports symbol='virDomainSetMemory' type='function'/>
     <exports symbol='virStoragePoolCreate' type='function'/>
     <exports symbol='virNodeGetInfo' type='function'/>
     <exports symbol='virNetworkSetAutostart' type='function'/>
     <exports symbol='virDomainGetMaxMemory' type='function'/>
     <exports symbol='virStoragePoolFree' type='function'/>
     <exports symbol='virFreeCallback' type='function'/>
     <exports symbol='virNetworkDefineXML' type='function'/>
     <exports symbol='virNodeDeviceListCaps' type='function'/>
     <exports symbol='virDomainBlockStats' type='function'/>
     <exports symbol='virConnectOpenAuth' type='function'/>
     <exports symbol='virStoragePoolDelete' type='function'/>
     <exports symbol='virEventRemoveHandleFunc' type='function'/>
     <exports symbol='virStorageVolGetName' type='function'/>
     <exports symbol='virStoragePoolGetAutostart' type='function'/>
     <exports symbol='virDomainGetAutostart' type='function'/>
     <exports symbol='virStoragePoolListVolumes' type='function'/>
     <exports symbol='virConnectGetHostname' type='function'/>
     <exports symbol='virEventRemoveTimeoutFunc' type='function'/>
     <exports symbol='virDomainGetName' type='function'/>
     <exports symbol='virNetworkGetXMLDesc' type='function'/>
     <exports symbol='virConnectNumOfStoragePools' type='function'/>
     <exports symbol='virNetworkGetName' type='function'/>
     <exports symbol='virConnectListDefinedDomains' type='function'/>
     <exports symbol='virConnectGetCapabilities' type='function'/>
     <exports symbol='virDomainLookupByName' type='function'/>
     <exports symbol='virConnectFindStoragePoolSources' type='function'/>
     <exports symbol='virDomainPinVcpu' type='function'/>
     <exports symbol='virDomainRestore' type='function'/>
     <exports symbol='virStorageVolGetPath' type='function'/>
     <exports symbol='virNetworkLookupByUUIDString' type='function'/>
     <exports symbol='virConnectDomainEventCallback' type='function'/>
     <exports symbol='virDomainLookupByID' type='function'/>
     <exports symbol='virStorageVolDelete' type='function'/>
     <exports symbol='virStorageVolFree' type='function'/>
     <exports symbol='virDomainMemoryPeek' type='function'/>
     <exports symbol='virNetworkLookupByUUID' type='function'/>
     <exports symbol='virConnectListDefinedNetworks' type='function'/>
     <exports symbol='virDomainGetUUID' type='function'/>
     <exports symbol='virNetworkCreateXML' type='function'/>
     <exports symbol='virDomainGetVcpus' type='function'/>
     <exports symbol='virNodeDeviceLookupByName' type='function'/>
     <exports symbol='virStoragePoolGetInfo' type='function'/>
     <exports symbol='virDomainResume' type='function'/>
     <exports symbol='virNodeListDevices' type='function'/>
     <exports symbol='virStoragePoolRefresh' type='function'/>
     <exports symbol='virConnectNumOfDefinedDomains' type='function'/>
     <exports symbol='virStorageVolLookupByKey' type='function'/>
     <exports symbol='virDomainUndefine' type='function'/>
     <exports symbol='virDomainReboot' type='function'/>
     <exports symbol='virNetworkGetUUIDString' type='function'/>
     <exports symbol='virNetworkLookupByName' type='function'/>
     <exports symbol='virDomainGetMaxVcpus' type='function'/>
     <exports symbol='virEventHandleCallback' type='function'/>
     <exports symbol='virDomainGetSchedulerType' type='function'/>
     <exports symbol='virDomainDetachDevice' type='function'/>
     <exports symbol='virStoragePoolNumOfVolumes' type='function'/>
     <exports symbol='virStoragePoolGetUUIDString' type='function'/>
     <exports symbol='virStoragePoolUndefine' type='function'/>
     <exports symbol='virConnectAuthCallbackPtr' type='function'/>
     <exports symbol='virDomainAttachDevice' type='function'/>
     <exports symbol='virConnectGetURI' type='function'/>
     <exports symbol='virConnectOpenReadOnly' type='function'/>
     <exports symbol='virNetworkFree' type='function'/>
     <exports symbol='virStoragePoolLookupByUUID' type='function'/>
     <exports symbol='virEventAddHandleFunc' type='function'/>
     <exports symbol='virNetworkUndefine' type='function'/>
     <exports symbol='virConnectListDefinedStoragePools' type='function'/>
     <exports symbol='virEventTimeoutCallback' type='function'/>
     <exports symbol='virNodeDeviceNumOfCaps' type='function'/>
     <exports symbol='virNetworkGetConnect' type='function'/>
     <exports symbol='virNodeGetFreeMemory' type='function'/>
     <exports symbol='virStorageVolGetConnect' type='function'/>
     <exports symbol='virNodeNumOfDevices' type='function'/>
     <exports symbol='virStoragePoolDestroy' type='function'/>
     <exports symbol='virStoragePoolLookupByVolume' type='function'/>
     <exports symbol='virDomainLookupByUUID' type='function'/>
     <exports symbol='virDomainGetOSType' type='function'/>
     <exports symbol='virStoragePoolBuild' type='function'/>
     <exports symbol='virConnectGetMaxVcpus' type='function'/>
     <exports symbol='virDomainGetUUIDString' type='function'/>
     <exports symbol='virDomainGetConnect' type='function'/>
     <exports symbol='virConnectNumOfDefinedStoragePools' type='function'/>
     <exports symbol='virNodeDeviceGetParent' type='function'/>
     <exports symbol='virConnectOpen' type='function'/>
     <exports symbol='virDomainCreateXML' type='function'/>
     <exports symbol='virDomainSetVcpus' type='function'/>
     <exports symbol='virConnectDomainEventRegister' type='function'/>
     <exports symbol='virDomainGetID' type='function'/>
     <exports symbol='virDomainBlockPeek' type='function'/>
     <exports symbol='virEventAddTimeoutFunc' type='function'/>
     <exports symbol='virDomainInterfaceStats' type='function'/>
     <exports symbol='virConnectListNetworks' type='function'/>
    </file>
    <file name='virterror'>
     <summary>error handling interfaces for the libvirt library</summary>
     <description>Provides the interfaces of the libvirt library to handle errors raised while using the library. </description>
     <author>Daniel Veillard &lt;veillard@redhat.com&gt; </author>
     <exports symbol='VIR_ERR_XML_ERROR' type='enum'/>
     <exports symbol='VIR_ERR_RPC' type='enum'/>
     <exports symbol='VIR_ERR_SYSTEM_ERROR' type='enum'/>
     <exports symbol='VIR_FROM_TEST' type='enum'/>
     <exports symbol='VIR_ERR_WARNING' type='enum'/>
     <exports symbol='VIR_FROM_OPENVZ' type='enum'/>
     <exports symbol='VIR_ERR_NO_XEN' type='enum'/>
     <exports symbol='VIR_FROM_STATS_LINUX' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_ARG' type='enum'/>
     <exports symbol='VIR_FROM_XEN_INOTIFY' type='enum'/>
     <exports symbol='VIR_ERR_ERROR' type='enum'/>
     <exports symbol='VIR_ERR_NO_OS' type='enum'/>
     <exports symbol='VIR_ERR_NO_NODE_DEVICE' type='enum'/>
     <exports symbol='VIR_ERR_NO_DEVICE' type='enum'/>
     <exports symbol='VIR_ERR_NO_MEMORY' type='enum'/>
     <exports symbol='VIR_FROM_SEXPR' type='enum'/>
     <exports symbol='VIR_WAR_NO_NODE' type='enum'/>
     <exports symbol='VIR_FROM_RPC' type='enum'/>
     <exports symbol='VIR_FROM_UML' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_MAC' type='enum'/>
     <exports symbol='VIR_ERR_NO_STORAGE_VOL' type='enum'/>
     <exports symbol='VIR_FROM_NONE' type='enum'/>
     <exports symbol='VIR_ERR_DOM_EXIST' type='enum'/>
     <exports symbol='VIR_ERR_NO_XENSTORE' type='enum'/>
     <exports symbol='VIR_FROM_DOM' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_DOMAIN' type='enum'/>
     <exports symbol='VIR_ERR_NO_STORAGE_POOL' type='enum'/>
     <exports symbol='VIR_FROM_CONF' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_NETWORK' type='enum'/>
     <exports symbol='VIR_ERR_AUTH_FAILED' type='enum'/>
     <exports symbol='VIR_FROM_XML' type='enum'/>
     <exports symbol='VIR_ERR_OPERATION_DENIED' type='enum'/>
     <exports symbol='VIR_FROM_STORAGE' type='enum'/>
     <exports symbol='VIR_ERR_NO_KERNEL' type='enum'/>
     <exports symbol='VIR_ERR_GNUTLS_ERROR' type='enum'/>
     <exports symbol='VIR_ERR_POST_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_OS_TYPE' type='enum'/>
     <exports symbol='VIR_FROM_XENSTORE' type='enum'/>
     <exports symbol='VIR_WAR_NO_NETWORK' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_CONN' type='enum'/>
     <exports symbol='VIR_ERR_NONE' type='enum'/>
     <exports symbol='VIR_ERR_OK' type='enum'/>
     <exports symbol='VIR_ERR_XML_DETAIL' type='enum'/>
     <exports symbol='VIR_FROM_NET' type='enum'/>
     <exports symbol='VIR_FROM_XENXM' type='enum'/>
     <exports symbol='VIR_ERR_NO_NAME' type='enum'/>
     <exports symbol='VIR_ERR_NO_ROOT' type='enum'/>
     <exports symbol='VIR_ERR_OPERATION_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_GET_FAILED' type='enum'/>
     <exports symbol='VIR_FROM_NODEDEV' type='enum'/>
     <exports symbol='VIR_ERR_DRIVER_FULL' type='enum'/>
     <exports symbol='VIR_ERR_HTTP_ERROR' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_NODE_DEVICE' type='enum'/>
     <exports symbol='VIR_ERR_PARSE_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_NO_SOURCE' type='enum'/>
     <exports symbol='VIR_FROM_DOMAIN' type='enum'/>
     <exports symbol='VIR_ERR_NO_TARGET' type='enum'/>
     <exports symbol='VIR_ERR_NETWORK_EXIST' type='enum'/>
     <exports symbol='VIR_WAR_NO_STORAGE' type='enum'/>
     <exports symbol='VIR_ERR_WRITE_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_INTERNAL_ERROR' type='enum'/>
     <exports symbol='VIR_ERR_CONF_SYNTAX' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_STORAGE_POOL' type='enum'/>
     <exports symbol='VIR_FROM_REMOTE' type='enum'/>
     <exports symbol='VIR_ERR_NO_SUPPORT' type='enum'/>
     <exports symbol='VIR_FROM_NETWORK' type='enum'/>
     <exports symbol='VIR_FROM_QEMU' type='enum'/>
     <exports symbol='VIR_FROM_XEND' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_STORAGE_VOL' type='enum'/>
     <exports symbol='VIR_FROM_PROXY' type='enum'/>
     <exports symbol='VIR_ERR_NO_NETWORK' type='enum'/>
     <exports symbol='VIR_ERR_NO_DOMAIN' type='enum'/>
     <exports symbol='VIR_ERR_READ_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_SEXPR_SERIAL' type='enum'/>
     <exports symbol='VIR_FROM_LXC' type='enum'/>
     <exports symbol='VIR_FROM_XEN' type='enum'/>
     <exports symbol='VIR_ERR_OPEN_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_XEN_CALL' type='enum'/>
     <exports symbol='VIR_ERR_UNKNOWN_HOST' type='enum'/>
     <exports symbol='VIR_ERR_NO_CONNECT' type='enum'/>
     <exports symbol='VIR_ERR_CALL_FAILED' type='enum'/>
     <exports symbol='virErrorPtr' type='typedef'/>
     <exports symbol='virErrorLevel' type='typedef'/>
     <exports symbol='virErrorDomain' type='typedef'/>
     <exports symbol='virErrorNumber' type='typedef'/>
     <exports symbol='virError' type='typedef'/>
     <exports symbol='_virError' type='struct'/>
     <exports symbol='virCopyLastError' type='function'/>
     <exports symbol='virConnSetErrorFunc' type='function'/>
     <exports symbol='virResetLastError' type='function'/>
     <exports symbol='virErrorFunc' type='function'/>
     <exports symbol='virResetError' type='function'/>
     <exports symbol='virConnGetLastError' type='function'/>
     <exports symbol='virDefaultErrorFunc' type='function'/>
     <exports symbol='virGetLastError' type='function'/>
     <exports symbol='virSetErrorFunc' type='function'/>
     <exports symbol='virConnCopyLastError' type='function'/>
     <exports symbol='virConnResetLastError' type='function'/>
    </file>
  </files>
  <symbols>
    <macro name='LIBVIR_VERSION_NUMBER' file='libvirt'>
      <info>Macro providing the version of the library as version * 1,000,000 + minor * 1000 + micro</info>
    </macro>
    <macro name='VIR_COPY_CPUMAP' file='libvirt'>
      <info>This macro is to be used in conjunction with virDomainGetVcpus() and virDomainPinVcpu() APIs. VIR_COPY_CPUMAP macro extract the cpumap of the specified vcpu from cpumaps array and copy it into cpumap to be used later by virDomainPinVcpu() API.</info>
      <arg name='cpumaps' info='pointer to an array of cpumap (in 8-bit bytes) (IN)'/>
      <arg name='maplen' info='the length (in bytes) of one cpumap'/>
      <arg name='vcpu' info='the virtual CPU number'/>
      <arg name='cpumap' info='pointer to a cpumap (in 8-bit bytes) (OUT) This cpumap must be previously allocated by the caller (ie: malloc(maplen))'/>
    </macro>
    <macro name='VIR_CPU_MAPLEN' file='libvirt'>
      <info>This macro is to be used in conjunction with virDomainPinVcpu() API. It returns the length (in bytes) required to store the complete CPU map between a single virtual &amp; all physical CPUs of a domain.</info>
      <arg name='cpu' info='number of physical CPUs'/>
    </macro>
    <macro name='VIR_CPU_USABLE' file='libvirt'>
      <info>This macro is to be used in conjunction with virDomainGetVcpus() API. VIR_CPU_USABLE macro returns a non zero value (true) if the cpu is usable by the vcpu, and 0 otherwise.</info>
      <arg name='cpumaps' info='pointer to an array of cpumap (in 8-bit bytes) (IN)'/>
      <arg name='maplen' info='the length (in bytes) of one cpumap'/>
      <arg name='vcpu' info='the virtual CPU number'/>
      <arg name='cpu' info='the physical CPU number'/>
    </macro>
    <macro name='VIR_DOMAIN_SCHED_FIELD_LENGTH' file='libvirt'>
      <info>Macro providing the field length of virSchedParameter</info>
    </macro>
    <macro name='VIR_GET_CPUMAP' file='libvirt'>
      <info>This macro is to be used in conjunction with virDomainGetVcpus() and virDomainPinVcpu() APIs. VIR_GET_CPUMAP macro returns a pointer to the cpumap of the specified vcpu from cpumaps array.</info>
      <arg name='cpumaps' info='pointer to an array of cpumap (in 8-bit bytes) (IN)'/>
      <arg name='maplen' info='the length (in bytes) of one cpumap'/>
      <arg name='vcpu' info='the virtual CPU number'/>
    </macro>
    <macro name='VIR_NODEINFO_MAXCPUS' file='libvirt'>
      <info>This macro is to calculate the total number of CPUs supported but not necessary active in the host.</info>
      <arg name='nodeinfo' info='virNodeInfo instance'/>
    </macro>
    <macro name='VIR_UNUSE_CPU' file='libvirt'>
      <info>This macro is to be used in conjunction with virDomainPinVcpu() API. USE_CPU macro reset the bit (CPU not usable) of the related cpu in cpumap.</info>
      <arg name='cpumap' info='pointer to a bit map of real CPUs (in 8-bit bytes) (IN/OUT)'/>
      <arg name='cpu' info='the physical CPU number'/>
    </macro>
    <macro name='VIR_USE_CPU' file='libvirt'>
      <info>This macro is to be used in conjunction with virDomainPinVcpu() API. USE_CPU macro set the bit (CPU usable) of the related cpu in cpumap.</info>
      <arg name='cpumap' info='pointer to a bit map of real CPUs (in 8-bit bytes) (IN/OUT)'/>
      <arg name='cpu' info='the physical CPU number'/>
    </macro>
    <macro name='VIR_UUID_BUFLEN' file='libvirt'>
      <info>This macro provides the length of the buffer required for virDomainGetUUID()</info>
    </macro>
    <macro name='VIR_UUID_STRING_BUFLEN' file='libvirt'>
      <info>This macro provides the length of the buffer required for virDomainGetUUIDString()</info>
    </macro>
    <enum name='VIR_CONNECT_RO' file='libvirt' value='1' type='virConnectFlags' info=' A readonly connection'/>
    <enum name='VIR_CRED_AUTHNAME' file='libvirt' value='2' type='virConnectCredentialType' info='Identify to authorize as'/>
    <enum name='VIR_CRED_CNONCE' file='libvirt' value='4' type='virConnectCredentialType' info='client supplies a nonce'/>
    <enum name='VIR_CRED_ECHOPROMPT' file='libvirt' value='6' type='virConnectCredentialType' info='Challenge response'/>
    <enum name='VIR_CRED_EXTERNAL' file='libvirt' value='9' type='virConnectCredentialType' info=' Externally managed credential More may be added - expect the unexpected'/>
    <enum name='VIR_CRED_LANGUAGE' file='libvirt' value='3' type='virConnectCredentialType' info='RFC 1766 languages, comma separated'/>
    <enum name='VIR_CRED_NOECHOPROMPT' file='libvirt' value='7' type='virConnectCredentialType' info='Challenge response'/>
    <enum name='VIR_CRED_PASSPHRASE' file='libvirt' value='5' type='virConnectCredentialType' info='Passphrase secret'/>
    <enum name='VIR_CRED_REALM' file='libvirt' value='8' type='virConnectCredentialType' info='Authentication realm'/>
    <enum name='VIR_CRED_USERNAME' file='libvirt' value='1' type='virConnectCredentialType' info='Identity to act as'/>
    <enum name='VIR_DOMAIN_BLOCKED' file='libvirt' value='2' type='virDomainState' info='the domain is blocked on resource'/>
    <enum name='VIR_DOMAIN_CRASHED' file='libvirt' value='6' type='virDomainState' info=' the domain is crashed'/>
    <enum name='VIR_DOMAIN_EVENT_DEFINED' file='libvirt' value='0' type='virDomainEventType'/>
    <enum name='VIR_DOMAIN_EVENT_DEFINED_ADDED' file='libvirt' value='0' type='virDomainEventDefinedDetailType' info='Newly created config file'/>
    <enum name='VIR_DOMAIN_EVENT_DEFINED_UPDATED' file='libvirt' value='1' type='virDomainEventDefinedDetailType' info=' Changed config file'/>
    <enum name='VIR_DOMAIN_EVENT_RESUMED' file='libvirt' value='4' type='virDomainEventType'/>
    <enum name='VIR_DOMAIN_EVENT_RESUMED_MIGRATED' file='libvirt' value='1' type='virDomainEventResumedDetailType' info=' Resumed for completion of migration'/>
    <enum name='VIR_DOMAIN_EVENT_RESUMED_UNPAUSED' file='libvirt' value='0' type='virDomainEventResumedDetailType' info='Normal resume due to admin unpause'/>
    <enum name='VIR_DOMAIN_EVENT_STARTED' file='libvirt' value='2' type='virDomainEventType'/>
    <enum name='VIR_DOMAIN_EVENT_STARTED_BOOTED' file='libvirt' value='0' type='virDomainEventStartedDetailType' info='Normal startup from boot'/>
    <enum name='VIR_DOMAIN_EVENT_STARTED_MIGRATED' file='libvirt' value='1' type='virDomainEventStartedDetailType' info='Incoming migration from another host'/>
    <enum name='VIR_DOMAIN_EVENT_STARTED_RESTORED' file='libvirt' value='2' type='virDomainEventStartedDetailType' info=' Restored from a state file'/>
    <enum name='VIR_DOMAIN_EVENT_STOPPED' file='libvirt' value='5' type='virDomainEventType'/>
    <enum name='VIR_DOMAIN_EVENT_STOPPED_CRASHED' file='libvirt' value='2' type='virDomainEventStoppedDetailType' info='Guest crashed'/>
    <enum name='VIR_DOMAIN_EVENT_STOPPED_DESTROYED' file='libvirt' value='1' type='virDomainEventStoppedDetailType' info='Forced poweroff from host'/>
    <enum name='VIR_DOMAIN_EVENT_STOPPED_FAILED' file='libvirt' value='5' type='virDomainEventStoppedDetailType' info=' Host emulator/mgmt failed'/>
    <enum name='VIR_DOMAIN_EVENT_STOPPED_MIGRATED' file='libvirt' value='3' type='virDomainEventStoppedDetailType' info='Migrated off to another host'/>
    <enum name='VIR_DOMAIN_EVENT_STOPPED_SAVED' file='libvirt' value='4' type='virDomainEventStoppedDetailType' info='Saved to a state file'/>
    <enum name='VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN' file='libvirt' value='0' type='virDomainEventStoppedDetailType' info='Normal shutdown'/>
    <enum name='VIR_DOMAIN_EVENT_SUSPENDED' file='libvirt' value='3' type='virDomainEventType'/>
    <enum name='VIR_DOMAIN_EVENT_SUSPENDED_MIGRATED' file='libvirt' value='1' type='virDomainEventSuspendedDetailType' info=' Suspended for offline migration'/>
    <enum name='VIR_DOMAIN_EVENT_SUSPENDED_PAUSED' file='libvirt' value='0' type='virDomainEventSuspendedDetailType' info='Normal suspend due to admin pause'/>
    <enum name='VIR_DOMAIN_EVENT_UNDEFINED' file='libvirt' value='1' type='virDomainEventType'/>
    <enum name='VIR_DOMAIN_EVENT_UNDEFINED_REMOVED' file='libvirt' value='0' type='virDomainEventUndefinedDetailType' info=' Deleted the config file'/>
    <enum name='VIR_DOMAIN_NONE' file='libvirt' value='0' type='virDomainCreateFlags'/>
    <enum name='VIR_DOMAIN_NOSTATE' file='libvirt' value='0' type='virDomainState' info='no state'/>
    <enum name='VIR_DOMAIN_PAUSED' file='libvirt' value='3' type='virDomainState' info='the domain is paused by user'/>
    <enum name='VIR_DOMAIN_RUNNING' file='libvirt' value='1' type='virDomainState' info='the domain is running'/>
    <enum name='VIR_DOMAIN_SCHED_FIELD_BOOLEAN' file='libvirt' value='6' type='virSchedParameterType' info=' boolean(character) case'/>
    <enum name='VIR_DOMAIN_SCHED_FIELD_DOUBLE' file='libvirt' value='5' type='virSchedParameterType' info='double case'/>
    <enum name='VIR_DOMAIN_SCHED_FIELD_INT' file='libvirt' value='1' type='virSchedParameterType' info='integer case'/>
    <enum name='VIR_DOMAIN_SCHED_FIELD_LLONG' file='libvirt' value='3' type='virSchedParameterType' info='long long case'/>
    <enum name='VIR_DOMAIN_SCHED_FIELD_UINT' file='libvirt' value='2' type='virSchedParameterType' info='unsigned integer case'/>
    <enum name='VIR_DOMAIN_SCHED_FIELD_ULLONG' file='libvirt' value='4' type='virSchedParameterType' info='unsigned long long case'/>
    <enum name='VIR_DOMAIN_SHUTDOWN' file='libvirt' value='4' type='virDomainState' info='the domain is being shut down'/>
    <enum name='VIR_DOMAIN_SHUTOFF' file='libvirt' value='5' type='virDomainState' info='the domain is shut off'/>
    <enum name='VIR_DOMAIN_XML_INACTIVE' file='libvirt' value='2' type='virDomainXMLFlags' info=' dump inactive domain information'/>
    <enum name='VIR_DOMAIN_XML_SECURE' file='libvirt' value='1' type='virDomainXMLFlags' info='dump security sensitive information too'/>
    <enum name='VIR_ERR_AUTH_FAILED' file='virterror' value='45' type='virErrorNumber' info='authentication failed'/>
    <enum name='VIR_ERR_CALL_FAILED' file='virterror' value='26' type='virErrorNumber' info='not supported by the drivers (DEPRECATED)'/>
    <enum name='VIR_ERR_CONF_SYNTAX' file='virterror' value='33' type='virErrorNumber' info='failed to parse the syntax of a conf file'/>
    <enum name='VIR_ERR_DOM_EXIST' file='virterror' value='28' type='virErrorNumber' info='the domain already exist'/>
    <enum name='VIR_ERR_DRIVER_FULL' file='virterror' value='25' type='virErrorNumber' info='too many drivers registered'/>
    <enum name='VIR_ERR_ERROR' file='virterror' value='2' type='virErrorLevel' info=' An error'/>
    <enum name='VIR_ERR_GET_FAILED' file='virterror' value='10' type='virErrorNumber' info='a HTTP GET command to failed'/>
    <enum name='VIR_ERR_GNUTLS_ERROR' file='virterror' value='40' type='virErrorNumber' info='error from a GNUTLS call'/>
    <enum name='VIR_ERR_HTTP_ERROR' file='virterror' value='12' type='virErrorNumber' info='unexpected HTTP error code'/>
    <enum name='VIR_ERR_INTERNAL_ERROR' file='virterror' value='1' type='virErrorNumber' info='internal error'/>
    <enum name='VIR_ERR_INVALID_ARG' file='virterror' value='8' type='virErrorNumber' info='invalid function argument'/>
    <enum name='VIR_ERR_INVALID_CONN' file='virterror' value='6' type='virErrorNumber' info='invalid connection object'/>
    <enum name='VIR_ERR_INVALID_DOMAIN' file='virterror' value='7' type='virErrorNumber' info='invalid domain object'/>
    <enum name='VIR_ERR_INVALID_MAC' file='virterror' value='44' type='virErrorNumber' info='invalid MAC address'/>
    <enum name='VIR_ERR_INVALID_NETWORK' file='virterror' value='36' type='virErrorNumber' info='invalid network object'/>
    <enum name='VIR_ERR_INVALID_NODE_DEVICE' file='virterror' value='52' type='virErrorNumber' info='invalid node device object'/>
    <enum name='VIR_ERR_INVALID_STORAGE_POOL' file='virterror' value='46' type='virErrorNumber' info='invalid storage pool object'/>
    <enum name='VIR_ERR_INVALID_STORAGE_VOL' file='virterror' value='47' type='virErrorNumber' info='invalid storage vol object'/>
    <enum name='VIR_ERR_NETWORK_EXIST' file='virterror' value='37' type='virErrorNumber' info='the network already exist'/>
    <enum name='VIR_ERR_NONE' file='virterror' value='0' type='virErrorLevel'/>
    <enum name='VIR_ERR_NO_CONNECT' file='virterror' value='5' type='virErrorNumber' info='can&apos;t connect to hypervisor'/>
    <enum name='VIR_ERR_NO_DEVICE' file='virterror' value='23' type='virErrorNumber' info='missing domain devices information'/>
    <enum name='VIR_ERR_NO_DOMAIN' file='virterror' value='42' type='virErrorNumber' info='domain not found or unexpectedly disappeared'/>
    <enum name='VIR_ERR_NO_KERNEL' file='virterror' value='17' type='virErrorNumber' info='missing kernel information'/>
    <enum name='VIR_ERR_NO_MEMORY' file='virterror' value='2' type='virErrorNumber' info='memory allocation failure'/>
    <enum name='VIR_ERR_NO_NAME' file='virterror' value='21' type='virErrorNumber' info='missing domain name information'/>
    <enum name='VIR_ERR_NO_NETWORK' file='virterror' value='43' type='virErrorNumber' info='network not found'/>
    <enum name='VIR_ERR_NO_NODE_DEVICE' file='virterror' value='53' type='virErrorNumber' info=' node device not found'/>
    <enum name='VIR_ERR_NO_OS' file='virterror' value='22' type='virErrorNumber' info='missing domain OS information'/>
    <enum name='VIR_ERR_NO_ROOT' file='virterror' value='18' type='virErrorNumber' info='missing root device information'/>
    <enum name='VIR_ERR_NO_SOURCE' file='virterror' value='19' type='virErrorNumber' info='missing source device information'/>
    <enum name='VIR_ERR_NO_STORAGE_POOL' file='virterror' value='49' type='virErrorNumber' info='storage pool not found'/>
    <enum name='VIR_ERR_NO_STORAGE_VOL' file='virterror' value='50' type='virErrorNumber' info='storage pool not found'/>
    <enum name='VIR_ERR_NO_SUPPORT' file='virterror' value='3' type='virErrorNumber' info='no support for this function'/>
    <enum name='VIR_ERR_NO_TARGET' file='virterror' value='20' type='virErrorNumber' info='missing target device information'/>
    <enum name='VIR_ERR_NO_XEN' file='virterror' value='14' type='virErrorNumber' info='could not open Xen hypervisor control'/>
    <enum name='VIR_ERR_NO_XENSTORE' file='virterror' value='24' type='virErrorNumber' info='could not open Xen Store control'/>
    <enum name='VIR_ERR_OK' file='virterror' value='0' type='virErrorNumber'/>
    <enum name='VIR_ERR_OPEN_FAILED' file='virterror' value='30' type='virErrorNumber' info='failed to open a conf file'/>
    <enum name='VIR_ERR_OPERATION_DENIED' file='virterror' value='29' type='virErrorNumber' info='operation forbidden on read-only connections'/>
    <enum name='VIR_ERR_OPERATION_FAILED' file='virterror' value='9' type='virErrorNumber' info='a command to hypervisor failed'/>
    <enum name='VIR_ERR_OS_TYPE' file='virterror' value='16' type='virErrorNumber' info='unknown OS type'/>
    <enum name='VIR_ERR_PARSE_FAILED' file='virterror' value='32' type='virErrorNumber' info='failed to parse a conf file'/>
    <enum name='VIR_ERR_POST_FAILED' file='virterror' value='11' type='virErrorNumber' info='a HTTP POST command to failed'/>
    <enum name='VIR_ERR_READ_FAILED' file='virterror' value='31' type='virErrorNumber' info='failed to read a conf file'/>
    <enum name='VIR_ERR_RPC' file='virterror' value='39' type='virErrorNumber' info='some sort of RPC error'/>
    <enum name='VIR_ERR_SEXPR_SERIAL' file='virterror' value='13' type='virErrorNumber' info='failure to serialize an S-Expr'/>
    <enum name='VIR_ERR_SYSTEM_ERROR' file='virterror' value='38' type='virErrorNumber' info='general system call failure'/>
    <enum name='VIR_ERR_UNKNOWN_HOST' file='virterror' value='4' type='virErrorNumber' info='could not resolve hostname'/>
    <enum name='VIR_ERR_WARNING' file='virterror' value='1' type='virErrorLevel' info='A simple warning'/>
    <enum name='VIR_ERR_WRITE_FAILED' file='virterror' value='34' type='virErrorNumber' info='failed to write a conf file'/>
    <enum name='VIR_ERR_XEN_CALL' file='virterror' value='15' type='virErrorNumber' info='failure doing an hypervisor call'/>
    <enum name='VIR_ERR_XML_DETAIL' file='virterror' value='35' type='virErrorNumber' info='detail of an XML error'/>
    <enum name='VIR_ERR_XML_ERROR' file='virterror' value='27' type='virErrorNumber' info='an XML description is not well formed or broken'/>
    <enum name='VIR_EVENT_HANDLE_ERROR' file='libvirt' value='4' type='virEventHandleType'/>
    <enum name='VIR_EVENT_HANDLE_HANGUP' file='libvirt' value='8' type='virEventHandleType'/>
    <enum name='VIR_EVENT_HANDLE_READABLE' file='libvirt' value='1' type='virEventHandleType'/>
    <enum name='VIR_EVENT_HANDLE_WRITABLE' file='libvirt' value='2' type='virEventHandleType'/>
    <enum name='VIR_FROM_CONF' file='virterror' value='9' type='virErrorDomain' info='Error in the configuration file handling'/>
    <enum name='VIR_FROM_DOM' file='virterror' value='6' type='virErrorDomain' info='Error when operating on a domain'/>
    <enum name='VIR_FROM_DOMAIN' file='virterror' value='20' type='virErrorDomain' info='Error from domain config'/>
    <enum name='VIR_FROM_LXC' file='virterror' value='17' type='virErrorDomain' info='Error from Linux Container driver'/>
    <enum name='VIR_FROM_NET' file='virterror' value='11' type='virErrorDomain' info='Error when operating on a network'/>
    <enum name='VIR_FROM_NETWORK' file='virterror' value='19' type='virErrorDomain' info='Error from network config'/>
    <enum name='VIR_FROM_NODEDEV' file='virterror' value='22' type='virErrorDomain' info='Error from node device monitor'/>
    <enum name='VIR_FROM_NONE' file='virterror' value='0' type='virErrorDomain'/>
    <enum name='VIR_FROM_OPENVZ' file='virterror' value='14' type='virErrorDomain' info='Error from OpenVZ driver'/>
    <enum name='VIR_FROM_PROXY' file='virterror' value='8' type='virErrorDomain' info='Error in the proxy code'/>
    <enum name='VIR_FROM_QEMU' file='virterror' value='10' type='virErrorDomain' info='Error at the QEMU daemon'/>
    <enum name='VIR_FROM_REMOTE' file='virterror' value='13' type='virErrorDomain' info='Error from remote driver'/>
    <enum name='VIR_FROM_RPC' file='virterror' value='7' type='virErrorDomain' info='Error in the XML-RPC code'/>
    <enum name='VIR_FROM_SEXPR' file='virterror' value='4' type='virErrorDomain' info='Error in the S-Expression code'/>
    <enum name='VIR_FROM_STATS_LINUX' file='virterror' value='16' type='virErrorDomain' info='Error in the Linux Stats code'/>
    <enum name='VIR_FROM_STORAGE' file='virterror' value='18' type='virErrorDomain' info='Error from storage driver'/>
    <enum name='VIR_FROM_TEST' file='virterror' value='12' type='virErrorDomain' info='Error from test driver'/>
    <enum name='VIR_FROM_UML' file='virterror' value='21' type='virErrorDomain' info='Error at the UML driver'/>
    <enum name='VIR_FROM_XEN' file='virterror' value='1' type='virErrorDomain' info='Error at Xen hypervisor layer'/>
    <enum name='VIR_FROM_XEND' file='virterror' value='2' type='virErrorDomain' info='Error at connection with xend daemon'/>
    <enum name='VIR_FROM_XENSTORE' file='virterror' value='3' type='virErrorDomain' info='Error at connection with xen store'/>
    <enum name='VIR_FROM_XENXM' file='virterror' value='15' type='virErrorDomain' info='Error at Xen XM layer'/>
    <enum name='VIR_FROM_XEN_INOTIFY' file='virterror' value='23' type='virErrorDomain' info=' Error from xen inotify layer'/>
    <enum name='VIR_FROM_XML' file='virterror' value='5' type='virErrorDomain' info='Error in the XML code'/>
    <enum name='VIR_MEMORY_VIRTUAL' file='libvirt' value='1' type='virDomainMemoryFlags' info=' addresses are virtual addresses'/>
    <enum name='VIR_MIGRATE_LIVE' file='libvirt' value='1' type='virDomainMigrateFlags' info=' live migration'/>
    <enum name='VIR_STORAGE_POOL_BUILDING' file='libvirt' value='1' type='virStoragePoolState' info='Initializing pool, not available'/>
    <enum name='VIR_STORAGE_POOL_BUILD_NEW' file='libvirt' value='0' type='virStoragePoolBuildFlags' info='Regular build from scratch'/>
    <enum name='VIR_STORAGE_POOL_BUILD_REPAIR' file='libvirt' value='1' type='virStoragePoolBuildFlags' info='Repair / reinitialize'/>
    <enum name='VIR_STORAGE_POOL_BUILD_RESIZE' file='libvirt' value='2' type='virStoragePoolBuildFlags' info=' Extend existing pool'/>
    <enum name='VIR_STORAGE_POOL_DEGRADED' file='libvirt' value='3' type='virStoragePoolState' info=' Running degraded'/>
    <enum name='VIR_STORAGE_POOL_DELETE_NORMAL' file='libvirt' value='0' type='virStoragePoolDeleteFlags' info='Delete metadata only    (fast)'/>
    <enum name='VIR_STORAGE_POOL_DELETE_ZEROED' file='libvirt' value='1' type='virStoragePoolDeleteFlags' info=' Clear all data to zeros (slow)'/>
    <enum name='VIR_STORAGE_POOL_INACTIVE' file='libvirt' value='0' type='virStoragePoolState' info='Not running'/>
    <enum name='VIR_STORAGE_POOL_RUNNING' file='libvirt' value='2' type='virStoragePoolState' info='Running normally'/>
    <enum name='VIR_STORAGE_VOL_BLOCK' file='libvirt' value='1' type='virStorageVolType' info=' Block based volumes'/>
    <enum name='VIR_STORAGE_VOL_DELETE_NORMAL' file='libvirt' value='0' type='virStorageVolDeleteFlags' info='Delete metadata only    (fast)'/>
    <enum name='VIR_STORAGE_VOL_DELETE_ZEROED' file='libvirt' value='1' type='virStorageVolDeleteFlags' info=' Clear all data to zeros (slow)'/>
    <enum name='VIR_STORAGE_VOL_FILE' file='libvirt' value='0' type='virStorageVolType' info='Regular file based volumes'/>
    <enum name='VIR_VCPU_BLOCKED' file='libvirt' value='2' type='virVcpuState' info=' the virtual CPU is blocked on resource'/>
    <enum name='VIR_VCPU_OFFLINE' file='libvirt' value='0' type='virVcpuState' info='the virtual CPU is offline'/>
    <enum name='VIR_VCPU_RUNNING' file='libvirt' value='1' type='virVcpuState' info='the virtual CPU is running'/>
    <enum name='VIR_WAR_NO_NETWORK' file='virterror' value='41' type='virErrorNumber' info='failed to start network'/>
    <enum name='VIR_WAR_NO_NODE' file='virterror' value='51' type='virErrorNumber' info='failed to start node driver'/>
    <enum name='VIR_WAR_NO_STORAGE' file='virterror' value='48' type='virErrorNumber' info='failed to start storage'/>
    <struct name='virConnect' file='libvirt' type='struct _virConnect'/>
    <struct name='virConnectAuth' file='libvirt' type='struct _virConnectAuth'>
      <field name='credtype' type='int *' info=' List of supported virConnectCredentialType values'/>
      <field name='ncredtype' type='unsigned int' info=''/>
      <field name='cb' type='virConnectAuthCallbackPtr' info=' Callback used to collect credentials'/>
      <field name='cbdata' type='void *' info=''/>
    </struct>
    <typedef name='virConnectAuthPtr' file='libvirt' type='virConnectAuth *'/>
    <struct name='virConnectCredential' file='libvirt' type='struct _virConnectCredential'>
      <field name='type' type='int' info=' One of virConnectCredentialType constants'/>
      <field name='prompt' type='const char *' info=' Prompt to show to user'/>
      <field name='challenge' type='const char *' info=' Additional challenge to show'/>
      <field name='defresult' type='const char *' info=' Optional default result'/>
      <field name='result' type='char *' info=' Result to be filled with user response (or defresult)'/>
      <field name='resultlen' type='unsigned int' info=' Length of the result'/>
    </struct>
    <typedef name='virConnectCredentialPtr' file='libvirt' type='virConnectCredential *'/>
    <typedef name='virConnectCredentialType' file='libvirt' type='enum'/>
    <typedef name='virConnectFlags' file='libvirt' type='enum'/>
    <typedef name='virConnectPtr' file='libvirt' type='virConnect *'>
      <info>a virConnectPtr is pointer to a virConnect private structure, this is the type used to reference a connection to the Hypervisor in the API.</info>
    </typedef>
    <struct name='virDomain' file='libvirt' type='struct _virDomain'/>
    <typedef name='virDomainBlockStatsPtr' file='libvirt' type='virDomainBlockStatsStruct *'>
      <info>A pointer to a virDomainBlockStats structure</info>
    </typedef>
    <struct name='virDomainBlockStatsStruct' file='libvirt' type='struct _virDomainBlockStats'>
      <field name='rd_req' type='long long' info=' number of read requests'/>
      <field name='rd_bytes' type='long long' info=' number of read bytes'/>
      <field name='wr_req' type='long long' info=' number of write requests'/>
      <field name='wr_bytes' type='long long' info=' number of written bytes'/>
      <field name='errs' type='long long' info=' In Xen this returns the mysterious &apos;oo_req&apos;.'/>
    </struct>
    <typedef name='virDomainCreateFlags' file='libvirt' type='enum'/>
    <typedef name='virDomainEventDefinedDetailType' file='libvirt' type='enum'/>
    <typedef name='virDomainEventResumedDetailType' file='libvirt' type='enum'/>
    <typedef name='virDomainEventStartedDetailType' file='libvirt' type='enum'/>
    <typedef name='virDomainEventStoppedDetailType' file='libvirt' type='enum'/>
    <typedef name='virDomainEventSuspendedDetailType' file='libvirt' type='enum'/>
    <typedef name='virDomainEventType' file='libvirt' type='enum'/>
    <typedef name='virDomainEventUndefinedDetailType' file='libvirt' type='enum'/>
    <struct name='virDomainInfo' file='libvirt' type='struct _virDomainInfo'>
      <field name='state' type='unsigned char' info=' the running state, one of virDomainState'/>
      <field name='maxMem' type='unsigned long' info=' the maximum memory in KBytes allowed'/>
      <field name='memory' type='unsigned long' info=' the memory in KBytes used by the domain'/>
      <field name='nrVirtCpu' type='unsigned short' info=' the number of virtual CPUs for the domain'/>
      <field name='cpuTime' type='unsigned long long' info=' the CPU time used in nanoseconds'/>
    </struct>
    <typedef name='virDomainInfoPtr' file='libvirt' type='virDomainInfo *'>
      <info>a virDomainInfoPtr is a pointer to a virDomainInfo structure.</info>
    </typedef>
    <typedef name='virDomainInterfaceStatsPtr' file='libvirt' type='virDomainInterfaceStatsStruct *'>
      <info>A pointer to a virDomainInterfaceStats structure</info>
    </typedef>
    <struct name='virDomainInterfaceStatsStruct' file='libvirt' type='struct _virDomainInterfaceStats'>
      <field name='rx_bytes' type='long long' info=''/>
      <field name='rx_packets' type='long long' info=''/>
      <field name='rx_errs' type='long long' info=''/>
      <field name='rx_drop' type='long long' info=''/>
      <field name='tx_bytes' type='long long' info=''/>
      <field name='tx_packets' type='long long' info=''/>
      <field name='tx_errs' type='long long' info=''/>
      <field name='tx_drop' type='long long' info=''/>
    </struct>
    <typedef name='virDomainMemoryFlags' file='libvirt' type='enum'/>
    <typedef name='virDomainMigrateFlags' file='libvirt' type='enum'/>
    <typedef name='virDomainPtr' file='libvirt' type='virDomain *'>
      <info>a virDomainPtr is pointer to a virDomain private structure, this is the type used to reference a domain in the API.</info>
    </typedef>
    <typedef name='virDomainState' file='libvirt' type='enum'/>
    <typedef name='virDomainXMLFlags' file='libvirt' type='enum'/>
    <struct name='virError' file='virterror' type='struct _virError'>
      <field name='code' type='int' info=' The error code, a virErrorNumber'/>
      <field name='domain' type='int' info=' What part of the library raised this error'/>
      <field name='message' type='char *' info=' human-readable informative error message'/>
      <field name='level' type='virErrorLevel' info=' how consequent is the error'/>
      <field name='conn' type='virConnectPtr' info=' connection if available, deprecated
see note above'/>
      <field name='dom' type='virDomainPtr' info=' domain if available, deprecated
see note above'/>
      <field name='str1' type='char *' info=' extra string information'/>
      <field name='str2' type='char *' info=' extra string information'/>
      <field name='str3' type='char *' info=' extra string information'/>
      <field name='int1' type='int' info=' extra number information'/>
      <field name='int2' type='int' info=' extra number information'/>
      <field name='net' type='virNetworkPtr' info=' network if available, deprecated
see note above'/>
    </struct>
    <typedef name='virErrorDomain' file='virterror' type='enum'/>
    <typedef name='virErrorLevel' file='virterror' type='enum'/>
    <typedef name='virErrorNumber' file='virterror' type='enum'/>
    <typedef name='virErrorPtr' file='virterror' type='virError *'/>
    <typedef name='virEventHandleType' file='libvirt' type='enum'/>
    <struct name='virNetwork' file='libvirt' type='struct _virNetwork'/>
    <typedef name='virNetworkPtr' file='libvirt' type='virNetwork *'>
      <info>a virNetworkPtr is pointer to a virNetwork private structure, this is the type used to reference a virtual network in the API.</info>
    </typedef>
    <struct name='virNodeDevice' file='libvirt' type='struct _virNodeDevice'/>
    <typedef name='virNodeDevicePtr' file='libvirt' type='virNodeDevice *'>
      <info>A virNodeDevicePtr is a pointer to a virNodeDevice structure.  Get one via virNodeDeviceLookupByKey, virNodeDeviceLookupByName, or virNodeDeviceCreate.  Be sure to Call virNodeDeviceFree when done using a virNodeDevicePtr obtained from any of the above functions to avoid leaking memory.</info>
    </typedef>
    <struct name='virNodeInfo' file='libvirt' type='struct _virNodeInfo'>
      <field name='model' type='charmodel[32]' info=' string indicating the CPU model'/>
      <field name='memory' type='unsigned long' info=' memory size in kilobytes'/>
      <field name='cpus' type='unsigned int' info=' the number of active CPUs'/>
      <field name='mhz' type='unsigned int' info=' expected CPU frequency'/>
      <field name='nodes' type='unsigned int' info=' the number of NUMA cell, 1 for uniform mem access'/>
      <field name='sockets' type='unsigned int' info=' number of CPU socket per node'/>
      <field name='cores' type='unsigned int' info=' number of core per socket'/>
      <field name='threads' type='unsigned int' info=' number of threads per core'/>
    </struct>
    <typedef name='virNodeInfoPtr' file='libvirt' type='virNodeInfo *'>
      <info>a virNodeInfoPtr is a pointer to a virNodeInfo structure.</info>
    </typedef>
    <struct name='virSchedParameter' file='libvirt' type='struct _virSchedParameter'>
      <field name='field' type='charfield[VIR_DOMAIN_SCHED_FIELD_LENGTH]' info=' parameter name'/>
      <field name='type' type='int' info=' parameter type'/>
    </struct>
    <typedef name='virSchedParameterPtr' file='libvirt' type='virSchedParameter *'>
      <info>a virSchedParameterPtr is a pointer to a virSchedParameter structure.</info>
    </typedef>
    <typedef name='virSchedParameterType' file='libvirt' type='enum'/>
    <struct name='virStoragePool' file='libvirt' type='struct _virStoragePool'/>
    <typedef name='virStoragePoolBuildFlags' file='libvirt' type='enum'/>
    <typedef name='virStoragePoolDeleteFlags' file='libvirt' type='enum'/>
    <struct name='virStoragePoolInfo' file='libvirt' type='struct _virStoragePoolInfo'>
      <field name='state' type='int' info=' virStoragePoolState flags'/>
      <field name='capacity' type='unsigned long long' info=' Logical size bytes'/>
      <field name='allocation' type='unsigned long long' info=' Current allocation bytes'/>
      <field name='available' type='unsigned long long' info=' Remaining free space bytes'/>
    </struct>
    <typedef name='virStoragePoolInfoPtr' file='libvirt' type='virStoragePoolInfo *'/>
    <typedef name='virStoragePoolPtr' file='libvirt' type='virStoragePool *'>
      <info>a virStoragePoolPtr is pointer to a virStoragePool private structure, this is the type used to reference a storage pool in the API.</info>
    </typedef>
    <typedef name='virStoragePoolState' file='libvirt' type='enum'/>
    <struct name='virStorageVol' file='libvirt' type='struct _virStorageVol'/>
    <typedef name='virStorageVolDeleteFlags' file='libvirt' type='enum'/>
    <struct name='virStorageVolInfo' file='libvirt' type='struct _virStorageVolInfo'>
      <field name='type' type='int' info=' virStorageVolType flags'/>
      <field name='capacity' type='unsigned long long' info=' Logical size bytes'/>
      <field name='allocation' type='unsigned long long' info=' Current allocation bytes'/>
    </struct>
    <typedef name='virStorageVolInfoPtr' file='libvirt' type='virStorageVolInfo *'/>
    <typedef name='virStorageVolPtr' file='libvirt' type='virStorageVol *'>
      <info>a virStorageVolPtr is pointer to a virStorageVol private structure, this is the type used to reference a storage volume in the API.</info>
    </typedef>
    <typedef name='virStorageVolType' file='libvirt' type='enum'/>
    <struct name='virVcpuInfo' file='libvirt' type='struct _virVcpuInfo'>
      <field name='number' type='unsigned int' info=' virtual CPU number'/>
      <field name='state' type='int' info=' value from virVcpuState'/>
      <field name='cpuTime' type='unsigned long long' info=' CPU time used, in nanoseconds'/>
      <field name='cpu' type='int' info=' real CPU number, or -1 if offline'/>
    </struct>
    <typedef name='virVcpuInfoPtr' file='libvirt' type='virVcpuInfo *'/>
    <typedef name='virVcpuState' file='libvirt' type='enum'/>
    <variable name='virConnectAuthPtrDefault' file='libvirt' type='virConnectAuthPtr'/>
    <function name='virConnCopyLastError' file='virterror' module='virterror'>
      <info>Copy the content of the last error caught on that connection One will need to free the result with virResetError()</info>
      <return type='int' info='0 if no error was found and the error code otherwise and -1 in case of parameter error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='to' type='virErrorPtr' info='target to receive the copy'/>
    </function>
    <function name='virConnGetLastError' file='virterror' module='virterror'>
      <info>Provide a pointer to the last error caught on that connection Simpler but may not be suitable for multithreaded accesses, in which case use virConnCopyLastError()</info>
      <return type='virErrorPtr' info='a pointer to the last error or NULL if none occurred.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnResetLastError' file='virterror' module='virterror'>
      <info>Reset the last error caught on that connection</info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnSetErrorFunc' file='virterror' module='virterror'>
      <info>Set a connection error handling function, if @handler is NULL it will reset to default which is to pass error back to the global library handler.</info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='userData' type='void *' info='pointer to the user data provided in the handler callback'/>
      <arg name='handler' type='virErrorFunc' info='the function to get called in case of error or NULL'/>
    </function>
    <functype name='virConnectAuthCallbackPtr' file='libvirt' module='libvirt'>
      <info></info>
      <return type='int' info=''/>
      <arg name='cred' type='virConnectCredentialPtr' info=''/>
      <arg name='ncred' type='unsigned int' info=''/>
      <arg name='cbdata' type='void *' info=''/>
    </functype>
    <function name='virConnectClose' file='libvirt' module='libvirt'>
      <info>This function closes the connection to the Hypervisor. This should not be called if further interaction with the Hypervisor are needed especially if there is running domain which need further monitoring by the application.</info>
      <return type='int' info='0 in case of success or -1 in case of error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <functype name='virConnectDomainEventCallback' file='libvirt' module='libvirt'>
      <info>A callback function to be registered, and called when a domain event occurs</info>
      <return type='int' info=''/>
      <arg name='conn' type='virConnectPtr' info='virConnect connection'/>
      <arg name='dom' type='virDomainPtr' info='The domain on which the event occured'/>
      <arg name='event' type='int' info='The specfic virDomainEventType which occured'/>
      <arg name='detail' type='int' info='event specific detail information'/>
      <arg name='opaque' type='void *' info='opaque user data'/>
    </functype>
    <function name='virConnectDomainEventDeregister' file='libvirt' module='libvirt'>
      <info>Removes a Domain Event Callback. De-registering for a domain callback will disable delivery of this event type</info>
      <return type='int' info='0 on success, -1 on failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the connection'/>
      <arg name='cb' type='virConnectDomainEventCallback' info='callback to the function handling domain events'/>
    </function>
    <function name='virConnectDomainEventRegister' file='libvirt' module='libvirt'>
      <info>Adds a Domain Event Callback. Registering for a domain callback will enable delivery of the events</info>
      <return type='int' info='0 on success, -1 on failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the connection'/>
      <arg name='cb' type='virConnectDomainEventCallback' info='callback to the function handling domain events'/>
      <arg name='opaque' type='void *' info='opaque data to pass on to the callback'/>
      <arg name='freecb' type='virFreeCallback' info='optional function to deallocate opaque when not used anymore'/>
    </function>
    <function name='virConnectFindStoragePoolSources' file='libvirt' module='libvirt'>
      <info>Talks to a storage backend and attempts to auto-discover the set of available storage pool sources. e.g. For iSCSI this would be a set of iSCSI targets. For NFS this would be a list of exported paths.  The srcSpec (optional for some storage pool types, e.g. local ones) is an instance of the storage pool&apos;s source element specifying where to look for the pools.  srcSpec is not required for some types (e.g., those querying local storage resources only)</info>
      <return type='char *' info='an xml document consisting of a SourceList element containing a source document appropriate to the given pool type for each discovered source.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='type' type='const char *' info='type of storage pool sources to discover'/>
      <arg name='srcSpec' type='const char *' info='XML document specifying discovery source'/>
      <arg name='flags' type='unsigned int' info='flags for discovery (unused, pass 0)'/>
    </function>
    <function name='virConnectGetCapabilities' file='libvirt' module='libvirt'>
      <info>Provides capabilities of the hypervisor / driver.</info>
      <return type='char *' info='NULL in case of error, or an XML string defining the capabilities. The client must free the returned string after use.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectGetHostname' file='libvirt' module='libvirt'>
      <info>This returns the system hostname on which the hypervisor is running (the result of the gethostname(2) system call).  If we are connected to a remote system, then this returns the hostname of the remote system.</info>
      <return type='char *' info='the hostname which must be freed by the caller, or NULL if there was an error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to a hypervisor connection'/>
    </function>
    <function name='virConnectGetMaxVcpus' file='libvirt' module='libvirt'>
      <info>Provides the maximum number of virtual CPUs supported for a guest VM of a specific type. The &apos;type&apos; parameter here corresponds to the &apos;type&apos; attribute in the &lt;domain&gt; element of the XML.</info>
      <return type='int' info='the maximum of virtual CPU or -1 in case of error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='type' type='const char *' info='value of the &apos;type&apos; attribute in the &lt;domain&gt; element'/>
    </function>
    <function name='virConnectGetType' file='libvirt' module='libvirt'>
      <info>Get the name of the Hypervisor software used.</info>
      <return type='const char *' info='NULL in case of error, a static zero terminated string otherwise.  See also: http://www.redhat.com/archives/libvir-list/2007-February/msg00096.html'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectGetURI' file='libvirt' module='libvirt'>
      <info>This returns the URI (name) of the hypervisor connection. Normally this is the same as or similar to the string passed to the virConnectOpen/virConnectOpenReadOnly call, but the driver may make the URI canonical.  If name == NULL was passed to virConnectOpen, then the driver will return a non-NULL URI which can be used to connect to the same hypervisor later.</info>
      <return type='char *' info='the URI string which must be freed by the caller, or NULL if there was an error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to a hypervisor connection'/>
    </function>
    <function name='virConnectGetVersion' file='libvirt' module='libvirt'>
      <info>Get the version level of the Hypervisor running. This may work only with hypervisor call, i.e. with privileged access to the hypervisor, not with a Read-Only connection.</info>
      <return type='int' info='-1 in case of error, 0 otherwise. if the version can&apos;t be extracted by lack of capacities returns 0 and @hvVer is 0, otherwise @hvVer value is major * 1,000,000 + minor * 1,000 + release'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='hvVer' type='unsigned long *' info='return value for the version of the running hypervisor (OUT)'/>
    </function>
    <function name='virConnectListDefinedDomains' file='libvirt' module='libvirt'>
      <info>list the defined but inactive domains, stores the pointers to the names in @names</info>
      <return type='int' info='the number of names provided in the array or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='names' type='char ** const' info='pointer to an array to store the names'/>
      <arg name='maxnames' type='int' info='size of the array'/>
    </function>
    <function name='virConnectListDefinedNetworks' file='libvirt' module='libvirt'>
      <info>list the inactive networks, stores the pointers to the names in @names</info>
      <return type='int' info='the number of names provided in the array or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='names' type='char ** const' info='pointer to an array to store the names'/>
      <arg name='maxnames' type='int' info='size of the array'/>
    </function>
    <function name='virConnectListDefinedStoragePools' file='libvirt' module='libvirt'>
      <info>Provides the list of names of inactive storage pools upto maxnames. If there are more than maxnames, the remaining names will be silently ignored.</info>
      <return type='int' info='0 on success, -1 on error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='names' type='char ** const' info='array of char * to fill with pool names (allocated by caller)'/>
      <arg name='maxnames' type='int' info='size of the names array'/>
    </function>
    <function name='virConnectListDomains' file='libvirt' module='libvirt'>
      <info>Collect the list of active domains, and store their ID in @maxids</info>
      <return type='int' info='the number of domain found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='ids' type='int *' info='array to collect the list of IDs of active domains'/>
      <arg name='maxids' type='int' info='size of @ids'/>
    </function>
    <function name='virConnectListNetworks' file='libvirt' module='libvirt'>
      <info>Collect the list of active networks, and store their names in @names</info>
      <return type='int' info='the number of networks found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='names' type='char ** const' info='array to collect the list of names of active networks'/>
      <arg name='maxnames' type='int' info='size of @names'/>
    </function>
    <function name='virConnectListStoragePools' file='libvirt' module='libvirt'>
      <info>Provides the list of names of active storage pools upto maxnames. If there are more than maxnames, the remaining names will be silently ignored.</info>
      <return type='int' info='0 on success, -1 on error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='names' type='char ** const' info='array of char * to fill with pool names (allocated by caller)'/>
      <arg name='maxnames' type='int' info='size of the names array'/>
    </function>
    <function name='virConnectNumOfDefinedDomains' file='libvirt' module='libvirt'>
      <info>Provides the number of defined but inactive domains.</info>
      <return type='int' info='the number of domain found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectNumOfDefinedNetworks' file='libvirt' module='libvirt'>
      <info>Provides the number of inactive networks.</info>
      <return type='int' info='the number of networks found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectNumOfDefinedStoragePools' file='libvirt' module='libvirt'>
      <info>Provides the number of inactive storage pools</info>
      <return type='int' info='the number of pools found, or -1 on error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
    </function>
    <function name='virConnectNumOfDomains' file='libvirt' module='libvirt'>
      <info>Provides the number of active domains.</info>
      <return type='int' info='the number of domain found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectNumOfNetworks' file='libvirt' module='libvirt'>
      <info>Provides the number of active networks.</info>
      <return type='int' info='the number of network found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectNumOfStoragePools' file='libvirt' module='libvirt'>
      <info>Provides the number of active storage pools</info>
      <return type='int' info='the number of pools found, or -1 on error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
    </function>
    <function name='virConnectOpen' file='libvirt' module='libvirt'>
      <info>This function should be called first to get a connection to the Hypervisor and xen store</info>
      <return type='virConnectPtr' info='a pointer to the hypervisor connection or NULL in case of error  URIs are documented at http://libvirt.org/uri.html'/>
      <arg name='name' type='const char *' info='URI of the hypervisor'/>
    </function>
    <function name='virConnectOpenAuth' file='libvirt' module='libvirt'>
      <info>This function should be called first to get a connection to the Hypervisor. If necessary, authentication will be performed fetching credentials via the callback</info>
      <return type='virConnectPtr' info='a pointer to the hypervisor connection or NULL in case of error  URIs are documented at http://libvirt.org/uri.html'/>
      <arg name='name' type='const char *' info='URI of the hypervisor'/>
      <arg name='auth' type='virConnectAuthPtr' info='Authenticate callback parameters'/>
      <arg name='flags' type='int' info='Open flags'/>
    </function>
    <function name='virConnectOpenReadOnly' file='libvirt' module='libvirt'>
      <info>This function should be called first to get a restricted connection to the library functionalities. The set of APIs usable are then restricted on the available methods to control the domains.</info>
      <return type='virConnectPtr' info='a pointer to the hypervisor connection or NULL in case of error  URIs are documented at http://libvirt.org/uri.html'/>
      <arg name='name' type='const char *' info='URI of the hypervisor'/>
    </function>
    <function name='virCopyLastError' file='virterror' module='virterror'>
      <info>Copy the content of the last error caught at the library level One will need to free the result with virResetError()</info>
      <return type='int' info='0 if no error was found and the error code otherwise and -1 in case of parameter error.'/>
      <arg name='to' type='virErrorPtr' info='target to receive the copy'/>
    </function>
    <function name='virDefaultErrorFunc' file='virterror' module='virterror'>
      <info>Default routine reporting an error to stderr.</info>
      <return type='void'/>
      <arg name='err' type='virErrorPtr' info='pointer to the error.'/>
    </function>
    <function name='virDomainAttachDevice' file='libvirt' module='libvirt'>
      <info>Create a virtual device attachment to backend.</info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='xml' type='const char *' info='pointer to XML description of one device'/>
    </function>
    <function name='virDomainBlockPeek' file='libvirt' module='libvirt'>
      <info>This function allows you to read the contents of a domain&apos;s disk device.  Typical uses for this are to determine if the domain has written a Master Boot Record (indicating that the domain has completed installation), or to try to work out the state of the domain&apos;s filesystems.  (Note that in the local case you might try to open the block device or file directly, but that won&apos;t work in the remote case, nor if you don&apos;t have sufficient permission. Hence the need for this call).  &apos;path&apos; must be a device or file corresponding to the domain. In other words it must be the precise string returned in a &lt;disk&gt;&lt;source dev=&apos;...&apos;/&gt;&lt;/disk&gt; from virDomainGetXMLDesc.  &apos;offset&apos; and &apos;size&apos; represent an area which must lie entirely within the device or file.  &apos;size&apos; may be 0 to test if the call would succeed.  &apos;buffer&apos; is the return buffer and must be at least &apos;size&apos; bytes.  NB. The remote driver imposes a 64K byte limit on &apos;size&apos;. For your program to be able to work reliably over a remote connection you should split large requests to &lt;= 65536 bytes.</info>
      <return type='int' info='0 in case of success or -1 in case of failure. really 64 bits'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain object'/>
      <arg name='path' type='const char *' info='path to the block device'/>
      <arg name='offset' type='unsigned long long' info='offset within block device'/>
      <arg name='size' type='size_t' info='size to read'/>
      <arg name='buffer' type='void *' info='return buffer (must be at least size bytes)'/>
      <arg name='flags' type='unsigned int' info='unused, always pass 0'/>
    </function>
    <function name='virDomainBlockStats' file='libvirt' module='libvirt'>
      <info>This function returns block device (disk) stats for block devices attached to the domain.  The path parameter is the name of the block device.  Get this by calling virDomainGetXMLDesc and finding the &lt;target dev=&apos;...&apos;&gt; attribute within //domain/devices/disk.  (For example, &quot;xvda&quot;).  Domains may have more than one block device.  To get stats for each you should make multiple calls to this function.  Individual fields within the stats structure may be returned as -1, which indicates that the hypervisor does not support that particular statistic.</info>
      <return type='int' info='0 in case of success or -1 in case of failure.'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain object'/>
      <arg name='path' type='const char *' info='path to the block device'/>
      <arg name='stats' type='virDomainBlockStatsPtr' info='block device stats (returned)'/>
      <arg name='size' type='size_t' info='size of stats structure'/>
    </function>
    <function name='virDomainCoreDump' file='libvirt' module='libvirt'>
      <info>This method will dump the core of a domain on a given file for analysis. Note that for remote Xen Daemon the file path will be interpreted in the remote host.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='to' type='const char *' info='path for the core file'/>
      <arg name='flags' type='int' info='extra flags, currently unused'/>
    </function>
    <function name='virDomainCreate' file='libvirt' module='libvirt'>
      <info>launch a defined domain. If the call succeed the domain moves from the defined to the running domains pools.</info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='domain' type='virDomainPtr' info='pointer to a defined domain'/>
    </function>
    <function name='virDomainCreateLinux' file='libvirt' module='libvirt'>
      <info>Deprecated after 0.4.6. Renamed to virDomainCreateXML() providing identical functionality. This existing name will left indefinitely for API compatability.</info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xmlDesc' type='const char *' info='string containing an XML description of the domain'/>
      <arg name='flags' type='unsigned int' info='callers should always pass 0'/>
    </function>
    <function name='virDomainCreateXML' file='libvirt' module='libvirt'>
      <info>Launch a new guest domain, based on an XML description similar to the one returned by virDomainGetXMLDesc() This function may requires privileged access to the hypervisor. The domain is not persistent, so its definition will disappear when it is destroyed, or if the host is restarted (see virDomainDefineXML() to define persistent domains).</info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xmlDesc' type='const char *' info='string containing an XML description of the domain'/>
      <arg name='flags' type='unsigned int' info='callers should always pass 0'/>
    </function>
    <function name='virDomainDefineXML' file='libvirt' module='libvirt'>
      <info>Define a domain, but does not start it. This definition is persistent, until explicitly undefined with virDomainUndefine().</info>
      <return type='virDomainPtr' info='NULL in case of error, a pointer to the domain otherwise'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xml' type='const char *' info='the XML description for the domain, preferably in UTF-8'/>
    </function>
    <function name='virDomainDestroy' file='libvirt' module='libvirt'>
      <info>Destroy the domain object. The running instance is shutdown if not down already and all resources used by it are given back to the hypervisor. This does not free the associated virDomainPtr object. This function may require privileged access</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainDetachDevice' file='libvirt' module='libvirt'>
      <info>Destroy a virtual device attachment to backend.</info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='xml' type='const char *' info='pointer to XML description of one device'/>
    </function>
    <function name='virDomainFree' file='libvirt' module='libvirt'>
      <info>Free the domain object. The running instance is kept alive. The data structure is freed and should not be used thereafter.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainGetAutostart' file='libvirt' module='libvirt'>
      <info>Provides a boolean value indicating whether the domain configured to be automatically started when the host machine boots.</info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='autostart' type='int *' info='the value returned'/>
    </function>
    <function name='virDomainGetConnect' file='libvirt' module='libvirt'>
      <info>Provides the connection pointer associated with a domain.  The reference counter on the connection is not increased by this call.  WARNING: When writing libvirt bindings in other languages, do not use this function.  Instead, store the connection and the domain object together.</info>
      <return type='virConnectPtr' info='the virConnectPtr or NULL in case of failure.'/>
      <arg name='dom' type='virDomainPtr' info='pointer to a domain'/>
    </function>
    <function name='virDomainGetID' file='libvirt' module='libvirt'>
      <info>Get the hypervisor ID number for the domain</info>
      <return type='unsigned int' info='the domain ID number or (unsigned int) -1 in case of error'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainGetInfo' file='libvirt' module='libvirt'>
      <info>Extract information about a domain. Note that if the connection used to get the domain is limited only a partial set of the information can be extracted.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='info' type='virDomainInfoPtr' info='pointer to a virDomainInfo structure allocated by the user'/>
    </function>
    <function name='virDomainGetMaxMemory' file='libvirt' module='libvirt'>
      <info>Retrieve the maximum amount of physical memory allocated to a domain. If domain is NULL, then this get the amount of memory reserved to Domain0 i.e. the domain where the application runs.</info>
      <return type='unsigned long' info='the memory size in kilobytes or 0 in case of error.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object or NULL'/>
    </function>
    <function name='virDomainGetMaxVcpus' file='libvirt' module='libvirt'>
      <info>Provides the maximum number of virtual CPUs supported for the guest VM. If the guest is inactive, this is basically the same as virConnectGetMaxVcpus. If the guest is running this will reflect the maximum number of virtual CPUs the guest was booted with.</info>
      <return type='int' info='the maximum of virtual CPU or -1 in case of error.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
    </function>
    <function name='virDomainGetName' file='libvirt' module='libvirt'>
      <info>Get the public name for that domain</info>
      <return type='const char *' info='a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the domain object.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainGetOSType' file='libvirt' module='libvirt'>
      <info>Get the type of domain operation system.</info>
      <return type='char *' info='the new string or NULL in case of error, the string must be freed by the caller.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainGetSchedulerParameters' file='libvirt' module='libvirt'>
      <info>Get the scheduler parameters, the @params array will be filled with the values.</info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='params' type='virSchedParameterPtr' info='pointer to scheduler parameter object (return value)'/>
      <arg name='nparams' type='int *' info='pointer to number of scheduler parameter (this value should be same than the returned value nparams of virDomainGetSchedulerType)'/>
    </function>
    <function name='virDomainGetSchedulerType' file='libvirt' module='libvirt'>
      <info>Get the scheduler type.</info>
      <return type='char *' info='NULL in case of error. The caller must free the returned string.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='nparams' type='int *' info='number of scheduler parameters(return value)'/>
    </function>
    <function name='virDomainGetUUID' file='libvirt' module='libvirt'>
      <info>Get the UUID for a domain</info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='uuid' type='unsigned char *' info='pointer to a VIR_UUID_BUFLEN bytes array'/>
    </function>
    <function name='virDomainGetUUIDString' file='libvirt' module='libvirt'>
      <info>Get the UUID for a domain as string. For more information about UUID see RFC4122.</info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='buf' type='char *' info='pointer to a VIR_UUID_STRING_BUFLEN bytes array'/>
    </function>
    <function name='virDomainGetVcpus' file='libvirt' module='libvirt'>
      <info>Extract information about virtual CPUs of domain, store it in info array and also in cpumaps if this pointer isn&apos;t NULL.</info>
      <return type='int' info='the number of info filled in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object, or NULL for Domain0'/>
      <arg name='info' type='virVcpuInfoPtr' info='pointer to an array of virVcpuInfo structures (OUT)'/>
      <arg name='maxinfo' type='int' info='number of structures in info array'/>
      <arg name='cpumaps' type='unsigned char *' info='pointer to an bit map of real CPUs for all vcpus of this domain (in 8-bit bytes) (OUT) If cpumaps is NULL, then no cpumap information is returned by the API. It&apos;s assumed there is &lt;maxinfo&gt; cpumap in cpumaps array. The memory allocated to cpumaps must be (maxinfo * maplen) bytes (ie: calloc(maxinfo, maplen)). One cpumap inside cpumaps has the format described in virDomainPinVcpu() API.'/>
      <arg name='maplen' type='int' info='number of bytes in one cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...).'/>
    </function>
    <function name='virDomainGetXMLDesc' file='libvirt' module='libvirt'>
      <info>Provide an XML description of the domain. The description may be reused later to relaunch the domain with virDomainCreateXML().</info>
      <return type='char *' info='a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='flags' type='int' info='an OR&apos;ed set of virDomainXMLFlags'/>
    </function>
    <function name='virDomainInterfaceStats' file='libvirt' module='libvirt'>
      <info>This function returns network interface stats for interfaces attached to the domain.  The path parameter is the name of the network interface.  Domains may have more than network interface.  To get stats for each you should make multiple calls to this function.  Individual fields within the stats structure may be returned as -1, which indicates that the hypervisor does not support that particular statistic.</info>
      <return type='int' info='0 in case of success or -1 in case of failure.'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain object'/>
      <arg name='path' type='const char *' info='path to the interface'/>
      <arg name='stats' type='virDomainInterfaceStatsPtr' info='network interface stats (returned)'/>
      <arg name='size' type='size_t' info='size of stats structure'/>
    </function>
    <function name='virDomainLookupByID' file='libvirt' module='libvirt'>
      <info>Try to find a domain based on the hypervisor ID number Note that this won&apos;t work for inactive domains which have an ID of -1, in that case a lookup based on the Name or UUId need to be done instead.</info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure.  If the domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='id' type='int' info='the domain ID number'/>
    </function>
    <function name='virDomainLookupByName' file='libvirt' module='libvirt'>
      <info>Try to lookup a domain on the given hypervisor based on its name.</info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure.  If the domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='name' type='const char *' info='name for the domain'/>
    </function>
    <function name='virDomainLookupByUUID' file='libvirt' module='libvirt'>
      <info>Try to lookup a domain on the given hypervisor based on its UUID.</info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure.  If the domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuid' type='const unsigned char *' info='the raw UUID for the domain'/>
    </function>
    <function name='virDomainLookupByUUIDString' file='libvirt' module='libvirt'>
      <info>Try to lookup a domain on the given hypervisor based on its UUID.</info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure.  If the domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuidstr' type='const char *' info='the string UUID for the domain'/>
    </function>
    <function name='virDomainMemoryPeek' file='libvirt' module='libvirt'>
      <info>This function allows you to read the contents of a domain&apos;s memory.  The memory which is read is controlled by the &apos;start&apos;, &apos;size&apos; and &apos;flags&apos; parameters.  If &apos;flags&apos; is VIR_MEMORY_VIRTUAL then the &apos;start&apos; and &apos;size&apos; parameters are interpreted as virtual memory addresses for whichever task happens to be running on the domain at the moment.  Although this sounds haphazard it is in fact what you want in order to read Linux kernel state, because it ensures that pointers in the kernel image can be interpreted coherently.  &apos;buffer&apos; is the return buffer and must be at least &apos;size&apos; bytes. &apos;size&apos; may be 0 to test if the call would succeed.  NB. The remote driver imposes a 64K byte limit on &apos;size&apos;. For your program to be able to work reliably over a remote connection you should split large requests to &lt;= 65536 bytes.</info>
      <return type='int' info='0 in case of success or -1 in case of failure. really 64 bits'/>
      <arg name='dom' type='virDomainPtr' info='pointer to the domain object'/>
      <arg name='start' type='unsigned long long' info='start of memory to peek'/>
      <arg name='size' type='size_t' info='size of memory to peek'/>
      <arg name='buffer' type='void *' info='return buffer (must be at least size bytes)'/>
      <arg name='flags' type='unsigned int' info='flags, see below'/>
    </function>
    <function name='virDomainMigrate' file='libvirt' module='libvirt'>
      <info>Migrate the domain object from its current host to the destination host given by dconn (a connection to the destination host).  Flags may be one of more of the following: VIR_MIGRATE_LIVE   Attempt a live migration.  If a hypervisor supports renaming domains during migration, then you may set the dname parameter to the new name (otherwise it keeps the same name).  If this is not supported by the hypervisor, dname must be NULL or else you will get an error.  Since typically the two hypervisors connect directly to each other in order to perform the migration, you may need to specify a path from the source to the destination.  This is the purpose of the uri parameter.  If uri is NULL, then libvirt will try to find the best method.  Uri may specify the hostname or IP address of the destination host as seen from the source.  Or uri may be a URI giving transport, hostname, user, port, etc. in the usual form.  Refer to driver documentation for the particular URIs supported.  The maximum bandwidth (in Mbps) that will be used to do migration can be specified with the bandwidth parameter.  If set to 0, libvirt will choose a suitable default.  Some hypervisors do not support this feature and will return an error if bandwidth is not 0.  To see which features are supported by the current hypervisor, see virConnectGetCapabilities, /capabilities/host/migration_features.  There are many limitations on migration imposed by the underlying technology - for example it may not be possible to migrate between different processors even with the same architecture, or between different types of hypervisor.</info>
      <return type='virDomainPtr' info='the new domain object if the migration was successful, or NULL in case of error.  Note that the new domain object exists in the scope of the destination connection (dconn).'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='dconn' type='virConnectPtr' info='destination host (a connection object)'/>
      <arg name='flags' type='unsigned long' info='flags'/>
      <arg name='dname' type='const char *' info='(optional) rename domain to this at destination'/>
      <arg name='uri' type='const char *' info='(optional) dest hostname/URI as seen from the source host'/>
      <arg name='bandwidth' type='unsigned long' info='(optional) specify migration bandwidth limit in Mbps'/>
    </function>
    <function name='virDomainPinVcpu' file='libvirt' module='libvirt'>
      <info>Dynamically change the real CPUs which can be allocated to a virtual CPU. This function requires privileged access to the hypervisor.</info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object, or NULL for Domain0'/>
      <arg name='vcpu' type='unsigned int' info='virtual CPU number'/>
      <arg name='cpumap' type='unsigned char *' info='pointer to a bit map of real CPUs (in 8-bit bytes) (IN) Each bit set to 1 means that corresponding CPU is usable. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit.'/>
      <arg name='maplen' type='int' info='number of bytes in cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). If maplen &lt; size, missing bytes are set to zero. If maplen &gt; size, failure code is returned.'/>
    </function>
    <function name='virDomainReboot' file='libvirt' module='libvirt'>
      <info>Reboot a domain, the domain object is still usable there after but the domain OS is being stopped for a restart. Note that the guest OS may ignore the request.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='flags' type='unsigned int' info='extra flags for the reboot operation, not used yet'/>
    </function>
    <function name='virDomainRestore' file='libvirt' module='libvirt'>
      <info>This method will restore a domain saved to disk by virDomainSave().</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='from' type='const char *' info='path to the'/>
    </function>
    <function name='virDomainResume' file='libvirt' module='libvirt'>
      <info>Resume an suspended domain, the process is restarted from the state where it was frozen by calling virSuspendDomain(). This function may requires privileged access</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainSave' file='libvirt' module='libvirt'>
      <info>This method will suspend a domain and save its memory contents to a file on disk. After the call, if successful, the domain is not listed as running anymore (this may be a problem). Use virDomainRestore() to restore a domain after saving.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='to' type='const char *' info='path for the output file'/>
    </function>
    <function name='virDomainSetAutostart' file='libvirt' module='libvirt'>
      <info>Configure the domain to be automatically started when the host machine boots.</info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='autostart' type='int' info='whether the domain should be automatically started 0 or 1'/>
    </function>
    <function name='virDomainSetMaxMemory' file='libvirt' module='libvirt'>
      <info>Dynamically change the maximum amount of physical memory allocated to a domain. If domain is NULL, then this change the amount of memory reserved to Domain0 i.e. the domain where the application runs. This function requires privileged access to the hypervisor.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object or NULL'/>
      <arg name='memory' type='unsigned long' info='the memory size in kilobytes'/>
    </function>
    <function name='virDomainSetMemory' file='libvirt' module='libvirt'>
      <info>Dynamically change the target amount of physical memory allocated to a domain. If domain is NULL, then this change the amount of memory reserved to Domain0 i.e. the domain where the application runs. This function may requires privileged access to the hypervisor.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object or NULL'/>
      <arg name='memory' type='unsigned long' info='the memory size in kilobytes'/>
    </function>
    <function name='virDomainSetSchedulerParameters' file='libvirt' module='libvirt'>
      <info>Change the scheduler parameters</info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='params' type='virSchedParameterPtr' info='pointer to scheduler parameter objects'/>
      <arg name='nparams' type='int' info='number of scheduler parameter (this value should be same or less than the returned value nparams of virDomainGetSchedulerType)'/>
    </function>
    <function name='virDomainSetVcpus' file='libvirt' module='libvirt'>
      <info>Dynamically change the number of virtual CPUs used by the domain. Note that this call may fail if the underlying virtualization hypervisor does not support it or if growing the number is arbitrary limited. This function requires privileged access to the hypervisor.</info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object, or NULL for Domain0'/>
      <arg name='nvcpus' type='unsigned int' info='the new number of virtual CPUs for this domain'/>
    </function>
    <function name='virDomainShutdown' file='libvirt' module='libvirt'>
      <info>Shutdown a domain, the domain object is still usable there after but the domain OS is being stopped. Note that the guest OS may ignore the request.  TODO: should we add an option for reboot, knowing it may not be doable in the general case ?</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainSuspend' file='libvirt' module='libvirt'>
      <info>Suspends an active domain, the process is frozen without further access to CPU resources and I/O but the memory used by the domain at the hypervisor level will stay allocated. Use virDomainResume() to reactivate the domain. This function may requires privileged access.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainUndefine' file='libvirt' module='libvirt'>
      <info>Undefine a domain but does not stop it if it is running</info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='domain' type='virDomainPtr' info='pointer to a defined domain'/>
    </function>
    <functype name='virErrorFunc' file='virterror' module='virterror'>
      <info>Signature of a function to use when there is an error raised by the library.</info>
      <return type='void'/>
      <arg name='userData' type='void *' info='user provided data for the error callback'/>
      <arg name='error' type='virErrorPtr' info='the error being raised.'/>
    </functype>
    <functype name='virEventAddHandleFunc' file='libvirt' module='libvirt'>
      <info>Part of the EventImpl, this callback Adds a file handle callback to listen for specific events. The same file handle can be registered multiple times provided the requested event sets are non-overlapping  If the opaque user data requires free&apos;ing when the handle is unregistered, then a 2nd callback can be supplied for this purpose.</info>
      <return type='int' info='a handle watch number to be used for updating and unregistering for events'/>
      <arg name='fd' type='int' info='file descriptor to listen on'/>
      <arg name='event' type='int' info='bitset of events on which to fire the callback'/>
      <arg name='cb' type='virEventHandleCallback' info='the callback to be called when an event occurrs'/>
      <arg name='opaque' type='void *' info='user data to pass to the callback'/>
      <arg name='ff' type='virFreeCallback' info='the callback invoked to free opaque data blob'/>
    </functype>
    <functype name='virEventAddTimeoutFunc' file='libvirt' module='libvirt'>
      <info>Part of the EventImpl, this user-defined callback handles adding an event timeout.  If the opaque user data requires free&apos;ing when the handle is unregistered, then a 2nd callback can be supplied for this purpose.</info>
      <return type='int' info='a timer value'/>
      <arg name='timeout' type='int' info='The timeout to monitor'/>
      <arg name='cb' type='virEventTimeoutCallback' info='the callback to call when timeout has expired'/>
      <arg name='opaque' type='void *' info='user data to pass to the callback'/>
      <arg name='ff' type='virFreeCallback' info='the callback invoked to free opaque data blob'/>
    </functype>
    <functype name='virEventHandleCallback' file='libvirt' module='libvirt'>
      <info>Callback for receiving file handle events. The callback will be invoked once for each event which is pending.</info>
      <return type='void'/>
      <arg name='watch' type='int' info='watch on which the event occurred'/>
      <arg name='fd' type='int' info='file handle on which the event occurred'/>
      <arg name='events' type='int' info='bitset of events from virEventHandleType constants'/>
      <arg name='opaque' type='void *' info='user data registered with handle'/>
    </functype>
    <function name='virEventRegisterImpl' file='libvirt' module='libvirt'>
      <info></info>
      <return type='void'/>
      <arg name='addHandle' type='virEventAddHandleFunc' info=''/>
      <arg name='updateHandle' type='virEventUpdateHandleFunc' info=''/>
      <arg name='removeHandle' type='virEventRemoveHandleFunc' info=''/>
      <arg name='addTimeout' type='virEventAddTimeoutFunc' info=''/>
      <arg name='updateTimeout' type='virEventUpdateTimeoutFunc' info=''/>
      <arg name='removeTimeout' type='virEventRemoveTimeoutFunc' info=''/>
    </function>
    <functype name='virEventRemoveHandleFunc' file='libvirt' module='libvirt'>
      <info>Part of the EventImpl, this user-provided callback is notified when an fd is no longer being listened on.  If a virEventHandleFreeFunc was supplied when the handle was registered, it will be invoked some time during, or after this function call, when it is safe to release the user data.</info>
      <return type='int' info=''/>
      <arg name='watch' type='int' info='file descriptor watch to stop listening on'/>
    </functype>
    <functype name='virEventRemoveTimeoutFunc' file='libvirt' module='libvirt'>
      <info>Part of the EventImpl, this user-defined callback removes a timer  If a virEventTimeoutFreeFunc was supplied when the handle was registered, it will be invoked some time during, or after this function call, when it is safe to release the user data.</info>
      <return type='int' info='0 on success, -1 on failure'/>
      <arg name='timer' type='int' info='the timer to remove'/>
    </functype>
    <functype name='virEventTimeoutCallback' file='libvirt' module='libvirt'>
      <info>callback for receiving timer events</info>
      <return type='void'/>
      <arg name='timer' type='int' info='timer id emitting the event'/>
      <arg name='opaque' type='void *' info='user data registered with handle'/>
    </functype>
    <functype name='virEventUpdateHandleFunc' file='libvirt' module='libvirt'>
      <info>Part of the EventImpl, this user-provided callback is notified when events to listen on change</info>
      <return type='void'/>
      <arg name='watch' type='int' info='file descriptor watch to modify'/>
      <arg name='event' type='int' info='new events to listen on'/>
    </functype>
    <functype name='virEventUpdateTimeoutFunc' file='libvirt' module='libvirt'>
      <info>Part of the EventImpl, this user-defined callback updates an event timeout.</info>
      <return type='void'/>
      <arg name='timer' type='int' info='the timer to modify'/>
      <arg name='timeout' type='int' info='the new timeout value'/>
    </functype>
    <functype name='virFreeCallback' file='libvirt' module='libvirt'>
      <info></info>
      <return type='void'/>
      <arg name='opaque' type='void *' info=''/>
    </functype>
    <function name='virGetLastError' file='virterror' module='virterror'>
      <info>Provide a pointer to the last error caught at the library level Simpler but may not be suitable for multithreaded accesses, in which case use virCopyLastError()</info>
      <return type='virErrorPtr' info='a pointer to the last error or NULL if none occurred.'/>
    </function>
    <function name='virGetVersion' file='libvirt' module='libvirt'>
      <info>Provides two information back, @libVer is the version of the library while @typeVer will be the version of the hypervisor type @type against which the library was compiled. If @type is NULL, &quot;Xen&quot; is assumed, if @type is unknown or not available, an error code will be returned and @typeVer will be 0.</info>
      <return type='int' info='-1 in case of failure, 0 otherwise, and values for @libVer and @typeVer have the format major * 1,000,000 + minor * 1,000 + release.'/>
      <arg name='libVer' type='unsigned long *' info='return value for the library version (OUT)'/>
      <arg name='type' type='const char *' info='the type of connection/driver looked at'/>
      <arg name='typeVer' type='unsigned long *' info='return value for the version of the hypervisor (OUT)'/>
    </function>
    <function name='virInitialize' file='libvirt' module='libvirt'>
      <info>Initialize the library. It&apos;s better to call this routine at startup in multithreaded applications to avoid potential race when initializing the library.</info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
    </function>
    <function name='virNetworkCreate' file='libvirt' module='libvirt'>
      <info>Create and start a defined network. If the call succeed the network moves from the defined to the running networks pools.</info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='network' type='virNetworkPtr' info='pointer to a defined network'/>
    </function>
    <function name='virNetworkCreateXML' file='libvirt' module='libvirt'>
      <info>Create and start a new virtual network, based on an XML description similar to the one returned by virNetworkGetXMLDesc()</info>
      <return type='virNetworkPtr' info='a new network object or NULL in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xmlDesc' type='const char *' info='an XML description of the network'/>
    </function>
    <function name='virNetworkDefineXML' file='libvirt' module='libvirt'>
      <info>Define a network, but does not create it</info>
      <return type='virNetworkPtr' info='NULL in case of error, a pointer to the network otherwise'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xml' type='const char *' info='the XML description for the network, preferably in UTF-8'/>
    </function>
    <function name='virNetworkDestroy' file='libvirt' module='libvirt'>
      <info>Destroy the network object. The running instance is shutdown if not down already and all resources used by it are given back to the hypervisor. This does not free the associated virNetworkPtr object. This function may require privileged access</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
    </function>
    <function name='virNetworkFree' file='libvirt' module='libvirt'>
      <info>Free the network object. The running instance is kept alive. The data structure is freed and should not be used thereafter.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
    </function>
    <function name='virNetworkGetAutostart' file='libvirt' module='libvirt'>
      <info>Provides a boolean value indicating whether the network configured to be automatically started when the host machine boots.</info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
      <arg name='autostart' type='int *' info='the value returned'/>
    </function>
    <function name='virNetworkGetBridgeName' file='libvirt' module='libvirt'>
      <info>Provides a bridge interface name to which a domain may connect a network interface in order to join the network.</info>
      <return type='char *' info='a 0 terminated interface name, or NULL in case of error. the caller must free() the returned value.'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
    </function>
    <function name='virNetworkGetConnect' file='libvirt' module='libvirt'>
      <info>Provides the connection pointer associated with a network.  The reference counter on the connection is not increased by this call.  WARNING: When writing libvirt bindings in other languages, do not use this function.  Instead, store the connection and the network object together.</info>
      <return type='virConnectPtr' info='the virConnectPtr or NULL in case of failure.'/>
      <arg name='net' type='virNetworkPtr' info='pointer to a network'/>
    </function>
    <function name='virNetworkGetName' file='libvirt' module='libvirt'>
      <info>Get the public name for that network</info>
      <return type='const char *' info='a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the network object.'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
    </function>
    <function name='virNetworkGetUUID' file='libvirt' module='libvirt'>
      <info>Get the UUID for a network</info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
      <arg name='uuid' type='unsigned char *' info='pointer to a VIR_UUID_BUFLEN bytes array'/>
    </function>
    <function name='virNetworkGetUUIDString' file='libvirt' module='libvirt'>
      <info>Get the UUID for a network as string. For more information about UUID see RFC4122.</info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
      <arg name='buf' type='char *' info='pointer to a VIR_UUID_STRING_BUFLEN bytes array'/>
    </function>
    <function name='virNetworkGetXMLDesc' file='libvirt' module='libvirt'>
      <info>Provide an XML description of the network. The description may be reused later to relaunch the network with virNetworkCreateXML().</info>
      <return type='char *' info='a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
      <arg name='flags' type='int' info='and OR&apos;ed set of extraction flags, not used yet'/>
    </function>
    <function name='virNetworkLookupByName' file='libvirt' module='libvirt'>
      <info>Try to lookup a network on the given hypervisor based on its name.</info>
      <return type='virNetworkPtr' info='a new network object or NULL in case of failure.  If the network cannot be found, then VIR_ERR_NO_NETWORK error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='name' type='const char *' info='name for the network'/>
    </function>
    <function name='virNetworkLookupByUUID' file='libvirt' module='libvirt'>
      <info>Try to lookup a network on the given hypervisor based on its UUID.</info>
      <return type='virNetworkPtr' info='a new network object or NULL in case of failure.  If the network cannot be found, then VIR_ERR_NO_NETWORK error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuid' type='const unsigned char *' info='the raw UUID for the network'/>
    </function>
    <function name='virNetworkLookupByUUIDString' file='libvirt' module='libvirt'>
      <info>Try to lookup a network on the given hypervisor based on its UUID.</info>
      <return type='virNetworkPtr' info='a new network object or NULL in case of failure.  If the network cannot be found, then VIR_ERR_NO_NETWORK error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuidstr' type='const char *' info='the string UUID for the network'/>
    </function>
    <function name='virNetworkSetAutostart' file='libvirt' module='libvirt'>
      <info>Configure the network to be automatically started when the host machine boots.</info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
      <arg name='autostart' type='int' info='whether the network should be automatically started 0 or 1'/>
    </function>
    <function name='virNetworkUndefine' file='libvirt' module='libvirt'>
      <info>Undefine a network but does not stop it if it is running</info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='network' type='virNetworkPtr' info='pointer to a defined network'/>
    </function>
    <function name='virNodeDeviceFree' file='libvirt' module='libvirt'>
      <info>Drops a reference to the node device, freeing it if this was the last reference.</info>
      <return type='int' info='the 0 for success, -1 for error.'/>
      <arg name='dev' type='virNodeDevicePtr' info='pointer to the node device'/>
    </function>
    <function name='virNodeDeviceGetName' file='libvirt' module='libvirt'>
      <info>Just return the device name</info>
      <return type='const char *' info='the device name or NULL in case of error'/>
      <arg name='dev' type='virNodeDevicePtr' info='the device'/>
    </function>
    <function name='virNodeDeviceGetParent' file='libvirt' module='libvirt'>
      <info>Accessor for the parent of the device</info>
      <return type='const char *' info='the name of the device&apos;s parent, or NULL if the device has no parent.'/>
      <arg name='dev' type='virNodeDevicePtr' info='the device'/>
    </function>
    <function name='virNodeDeviceGetXMLDesc' file='libvirt' module='libvirt'>
      <info>Fetch an XML document describing all aspects of the device.</info>
      <return type='char *' info='the XML document, or NULL on error'/>
      <arg name='dev' type='virNodeDevicePtr' info='pointer to the node device'/>
      <arg name='flags' type='unsigned int' info='flags for XML generation (unused, pass 0)'/>
    </function>
    <function name='virNodeDeviceListCaps' file='libvirt' module='libvirt'>
      <info>Lists the names of the capabilities supported by the device.</info>
      <return type='int' info='the number of capability names listed in @names.'/>
      <arg name='dev' type='virNodeDevicePtr' info='the device'/>
      <arg name='names' type='char ** const' info='array to collect the list of capability names'/>
      <arg name='maxnames' type='int' info='size of @names'/>
    </function>
    <function name='virNodeDeviceLookupByName' file='libvirt' module='libvirt'>
      <info>Lookup a node device by its name.</info>
      <return type='virNodeDevicePtr' info='a virNodeDevicePtr if found, NULL otherwise.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='name' type='const char *' info='unique device name'/>
    </function>
    <function name='virNodeDeviceNumOfCaps' file='libvirt' module='libvirt'>
      <info>Accessor for the number of capabilities supported by the device.</info>
      <return type='int' info='the number of capabilities supported by the device.'/>
      <arg name='dev' type='virNodeDevicePtr' info='the device'/>
    </function>
    <function name='virNodeGetCellsFreeMemory' file='libvirt' module='libvirt'>
      <info>This call returns the amount of free memory in one or more NUMA cells. The @freeMems array must be allocated by the caller and will be filled with the amount of free memory in kilobytes for each cell requested, starting with startCell (in freeMems[0]), up to either (startCell + maxCells), or the number of additional cells in the node, whichever is smaller.</info>
      <return type='int' info='the number of entries filled in freeMems, or -1 in case of error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='freeMems' type='unsigned long long *' info='pointer to the array of unsigned long long'/>
      <arg name='startCell' type='int' info='index of first cell to return freeMems info on.'/>
      <arg name='maxCells' type='int' info='Maximum number of cells for which freeMems information can be returned.'/>
    </function>
    <function name='virNodeGetFreeMemory' file='libvirt' module='libvirt'>
      <info>provides the free memory available on the Node</info>
      <return type='unsigned long long' info='the available free memory in kilobytes or 0 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virNodeGetInfo' file='libvirt' module='libvirt'>
      <info>Extract hardware information about the node.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='info' type='virNodeInfoPtr' info='pointer to a virNodeInfo structure allocated by the user'/>
    </function>
    <function name='virNodeListDevices' file='libvirt' module='libvirt'>
      <info>Collect the list of node devices, and store their names in @names  If the optional &apos;cap&apos;  argument is non-NULL, then the count will be restricted to devices with the specified capability</info>
      <return type='int' info='the number of node devices found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='cap' type='const char *' info='capability name'/>
      <arg name='names' type='char ** const' info='array to collect the list of node device names'/>
      <arg name='maxnames' type='int' info='size of @names'/>
      <arg name='flags' type='unsigned int' info='flags (unused, pass 0)'/>
    </function>
    <function name='virNodeNumOfDevices' file='libvirt' module='libvirt'>
      <info>Provides the number of node devices.  If the optional &apos;cap&apos;  argument is non-NULL, then the count will be restricted to devices with the specified capability</info>
      <return type='int' info='the number of node devices or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='cap' type='const char *' info='capability name'/>
      <arg name='flags' type='unsigned int' info='flags (unused, pass 0)'/>
    </function>
    <function name='virResetError' file='virterror' module='virterror'>
      <info>Reset the error being pointed to</info>
      <return type='void'/>
      <arg name='err' type='virErrorPtr' info='pointer to the virError to clean up'/>
    </function>
    <function name='virResetLastError' file='virterror' module='virterror'>
      <info>Reset the last error caught at the library level.</info>
      <return type='void'/>
    </function>
    <function name='virSetErrorFunc' file='virterror' module='virterror'>
      <info>Set a library global error handling function, if @handler is NULL, it will reset to default printing on stderr. The error raised there are those for which no handler at the connection level could caught.</info>
      <return type='void'/>
      <arg name='userData' type='void *' info='pointer to the user data provided in the handler callback'/>
      <arg name='handler' type='virErrorFunc' info='the function to get called in case of error or NULL'/>
    </function>
    <function name='virStoragePoolBuild' file='libvirt' module='libvirt'>
      <info>Build the underlying storage pool</info>
      <return type='int' info='0 on success, or -1 upon failure'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='flags' type='unsigned int' info='future flags, use 0 for now'/>
    </function>
    <function name='virStoragePoolCreate' file='libvirt' module='libvirt'>
      <info>Starts an inactive storage pool</info>
      <return type='int' info='0 on success, or -1 if it could not be started'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='flags' type='unsigned int' info='future flags, use 0 for now'/>
    </function>
    <function name='virStoragePoolCreateXML' file='libvirt' module='libvirt'>
      <info>Create a new storage based on its XML description. The pool is not persistent, so its definition will disappear when it is destroyed, or if the host is restarted</info>
      <return type='virStoragePoolPtr' info='a virStoragePoolPtr object, or NULL if creation failed'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='xmlDesc' type='const char *' info='XML description for new pool'/>
      <arg name='flags' type='unsigned int' info='future flags, use 0 for now'/>
    </function>
    <function name='virStoragePoolDefineXML' file='libvirt' module='libvirt'>
      <info>Define a new inactive storage pool based on its XML description. The pool is persistent, until explicitly undefined.</info>
      <return type='virStoragePoolPtr' info='a virStoragePoolPtr object, or NULL if creation failed'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='xml' type='const char *' info='XML description for new pool'/>
      <arg name='flags' type='unsigned int' info='future flags, use 0 for now'/>
    </function>
    <function name='virStoragePoolDelete' file='libvirt' module='libvirt'>
      <info>Delete the underlying pool resources. This is a non-recoverable operation. The virStoragePoolPtr object itself is not free&apos;d.</info>
      <return type='int' info='0 on success, or -1 if it could not be obliterate'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='flags' type='unsigned int' info='flags for obliteration process'/>
    </function>
    <function name='virStoragePoolDestroy' file='libvirt' module='libvirt'>
      <info>Destroy an active storage pool. This will deactivate the pool on the host, but keep any persistent config associated with it. If it has a persistent config it can later be restarted with virStoragePoolCreate(). This does not free the associated virStoragePoolPtr object.</info>
      <return type='int' info='0 on success, or -1 if it could not be destroyed'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
    </function>
    <function name='virStoragePoolFree' file='libvirt' module='libvirt'>
      <info>Free a storage pool object, releasing all memory associated with it. Does not change the state of the pool on the host.</info>
      <return type='int' info='0 on success, or -1 if it could not be free&apos;d.'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
    </function>
    <function name='virStoragePoolGetAutostart' file='libvirt' module='libvirt'>
      <info>Fetches the value of the autostart flag, which determines whether the pool is automatically started at boot time</info>
      <return type='int' info='0 on success, -1 on failure'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='autostart' type='int *' info='location in which to store autostart flag'/>
    </function>
    <function name='virStoragePoolGetConnect' file='libvirt' module='libvirt'>
      <info>Provides the connection pointer associated with a storage pool.  The reference counter on the connection is not increased by this call.  WARNING: When writing libvirt bindings in other languages, do not use this function.  Instead, store the connection and the pool object together.</info>
      <return type='virConnectPtr' info='the virConnectPtr or NULL in case of failure.'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to a pool'/>
    </function>
    <function name='virStoragePoolGetInfo' file='libvirt' module='libvirt'>
      <info>Get volatile information about the storage pool such as free space / usage summary</info>
      <return type='int' info='0 on success, or -1 on failure.'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='info' type='virStoragePoolInfoPtr' info='pointer at which to store info'/>
    </function>
    <function name='virStoragePoolGetName' file='libvirt' module='libvirt'>
      <info>Fetch the locally unique name of the storage pool</info>
      <return type='const char *' info='the name of the pool, or NULL on error'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
    </function>
    <function name='virStoragePoolGetUUID' file='libvirt' module='libvirt'>
      <info>Fetch the globally unique ID of the storage pool</info>
      <return type='int' info='0 on success, or -1 on error;'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='uuid' type='unsigned char *' info='buffer of VIR_UUID_BUFLEN bytes in size'/>
    </function>
    <function name='virStoragePoolGetUUIDString' file='libvirt' module='libvirt'>
      <info>Fetch the globally unique ID of the storage pool as a string</info>
      <return type='int' info='0 on success, or -1 on error;'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='buf' type='char *' info='buffer of VIR_UUID_STRING_BUFLEN bytes in size'/>
    </function>
    <function name='virStoragePoolGetXMLDesc' file='libvirt' module='libvirt'>
      <info>Fetch an XML document describing all aspects of the storage pool. This is suitable for later feeding back into the virStoragePoolCreateXML method.</info>
      <return type='char *' info='a XML document, or NULL on error'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='flags' type='unsigned int' info='flags for XML format options (set of virDomainXMLFlags)'/>
    </function>
    <function name='virStoragePoolListVolumes' file='libvirt' module='libvirt'>
      <info>Fetch list of storage volume names, limiting to at most maxnames.</info>
      <return type='int' info='the number of names fetched, or -1 on error'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='names' type='char ** const' info='array in which to storage volume names'/>
      <arg name='maxnames' type='int' info='size of names array'/>
    </function>
    <function name='virStoragePoolLookupByName' file='libvirt' module='libvirt'>
      <info>Fetch a storage pool based on its unique name</info>
      <return type='virStoragePoolPtr' info='a virStoragePoolPtr object, or NULL if no matching pool is found'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='name' type='const char *' info='name of pool to fetch'/>
    </function>
    <function name='virStoragePoolLookupByUUID' file='libvirt' module='libvirt'>
      <info>Fetch a storage pool based on its globally unique id</info>
      <return type='virStoragePoolPtr' info='a virStoragePoolPtr object, or NULL if no matching pool is found'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='uuid' type='const unsigned char *' info='globally unique id of pool to fetch'/>
    </function>
    <function name='virStoragePoolLookupByUUIDString' file='libvirt' module='libvirt'>
      <info>Fetch a storage pool based on its globally unique id</info>
      <return type='virStoragePoolPtr' info='a virStoragePoolPtr object, or NULL if no matching pool is found'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='uuidstr' type='const char *' info='globally unique id of pool to fetch'/>
    </function>
    <function name='virStoragePoolLookupByVolume' file='libvirt' module='libvirt'>
      <info>Fetch a storage pool which contains a particular volume</info>
      <return type='virStoragePoolPtr' info='a virStoragePoolPtr object, or NULL if no matching pool is found'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
    </function>
    <function name='virStoragePoolNumOfVolumes' file='libvirt' module='libvirt'>
      <info>Fetch the number of storage volumes within a pool</info>
      <return type='int' info='the number of storage pools, or -1 on failure'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
    </function>
    <function name='virStoragePoolRefresh' file='libvirt' module='libvirt'>
      <info>Request that the pool refresh its list of volumes. This may involve communicating with a remote server, and/or initializing new devices at the OS layer</info>
      <return type='int' info='0 if the volume list was refreshed, -1 on failure'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='flags' type='unsigned int' info='flags to control refresh behaviour (currently unused, use 0)'/>
    </function>
    <function name='virStoragePoolSetAutostart' file='libvirt' module='libvirt'>
      <info>Sets the autostart flag</info>
      <return type='int' info='0 on success, -1 on failure'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='autostart' type='int' info='new flag setting'/>
    </function>
    <function name='virStoragePoolUndefine' file='libvirt' module='libvirt'>
      <info>Undefine an inactive storage pool</info>
      <return type='int' info='a virStoragePoolPtr object, or NULL if creation failed'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
    </function>
    <function name='virStorageVolCreateXML' file='libvirt' module='libvirt'>
      <info>Create a storage volume within a pool based on an XML description. Not all pools support creation of volumes</info>
      <return type='virStorageVolPtr' info='the storage volume, or NULL on error'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='xmldesc' type='const char *' info='description of volume to create'/>
      <arg name='flags' type='unsigned int' info='flags for creation (unused, pass 0)'/>
    </function>
    <function name='virStorageVolDelete' file='libvirt' module='libvirt'>
      <info>Delete the storage volume from the pool</info>
      <return type='int' info='0 on success, or -1 on error'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
      <arg name='flags' type='unsigned int' info='future flags, use 0 for now'/>
    </function>
    <function name='virStorageVolFree' file='libvirt' module='libvirt'>
      <info>Release the storage volume handle. The underlying storage volume contains to exist</info>
      <return type='int' info='0 on success, or -1 on error'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
    </function>
    <function name='virStorageVolGetConnect' file='libvirt' module='libvirt'>
      <info>Provides the connection pointer associated with a storage volume.  The reference counter on the connection is not increased by this call.  WARNING: When writing libvirt bindings in other languages, do not use this function.  Instead, store the connection and the volume object together.</info>
      <return type='virConnectPtr' info='the virConnectPtr or NULL in case of failure.'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to a pool'/>
    </function>
    <function name='virStorageVolGetInfo' file='libvirt' module='libvirt'>
      <info>Fetches volatile information about the storage volume such as its current allocation</info>
      <return type='int' info='0 on success, or -1 on failure'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
      <arg name='info' type='virStorageVolInfoPtr' info='pointer at which to store info'/>
    </function>
    <function name='virStorageVolGetKey' file='libvirt' module='libvirt'>
      <info>Fetch the storage volume key. This is globally unique, so the same volume will have the same key no matter what host it is accessed from</info>
      <return type='const char *' info='the volume key, or NULL on error'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
    </function>
    <function name='virStorageVolGetName' file='libvirt' module='libvirt'>
      <info>Fetch the storage volume name. This is unique within the scope of a pool</info>
      <return type='const char *' info='the volume name, or NULL on error'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
    </function>
    <function name='virStorageVolGetPath' file='libvirt' module='libvirt'>
      <info>Fetch the storage volume path. Depending on the pool configuration this is either persistent across hosts, or dynamically assigned at pool startup. Consult pool documentation for information on getting the persistent naming</info>
      <return type='char *' info='the storage volume path, or NULL on error'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
    </function>
    <function name='virStorageVolGetXMLDesc' file='libvirt' module='libvirt'>
      <info>Fetch an XML document describing all aspects of the storage volume</info>
      <return type='char *' info='the XML document, or NULL on error'/>
      <arg name='vol' type='virStorageVolPtr' info='pointer to storage volume'/>
      <arg name='flags' type='unsigned int' info='flags for XML generation (unused, pass 0)'/>
    </function>
    <function name='virStorageVolLookupByKey' file='libvirt' module='libvirt'>
      <info>Fetch a pointer to a storage volume based on its globally unique key</info>
      <return type='virStorageVolPtr' info='a storage volume, or NULL if not found / error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='key' type='const char *' info='globally unique key'/>
    </function>
    <function name='virStorageVolLookupByName' file='libvirt' module='libvirt'>
      <info>Fetch a pointer to a storage volume based on its name within a pool</info>
      <return type='virStorageVolPtr' info='a storage volume, or NULL if not found / error'/>
      <arg name='pool' type='virStoragePoolPtr' info='pointer to storage pool'/>
      <arg name='name' type='const char *' info='name of storage volume'/>
    </function>
    <function name='virStorageVolLookupByPath' file='libvirt' module='libvirt'>
      <info>Fetch a pointer to a storage volume based on its locally (host) unique path</info>
      <return type='virStorageVolPtr' info='a storage volume, or NULL if not found / error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to hypervisor connection'/>
      <arg name='path' type='const char *' info='locally unique path'/>
    </function>
  </symbols>
</api>
